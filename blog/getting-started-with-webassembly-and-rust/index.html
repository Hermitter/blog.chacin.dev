<!doctype html> <head> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-157498342-1"></script> <script> window.dataLayer = window.dataLayer || [];
		function gtag(){dataLayer.push(arguments);}
		gtag('js', new Date());

		gtag('config', 'UA-157498342-1'); </script> <meta charset=utf-8> <meta content="width=device-width,initial-scale=1" name=viewport> <meta content=#333333 name=theme-color> <meta content=en-us http-equiv=content-language> <base href=/ > <link href=global.css rel=stylesheet> <link href=manifest.json rel=manifest> <link href=favicon.png rel=icon type=image/png> <link href=client/main.3807866553.css rel=stylesheet><link href=client/[slug].d3ae4ea4.css rel=stylesheet><link href=client/Icon.b4e05bae.css rel=stylesheet> <noscript id=sapper-head-start></noscript><title>Getting Started with WebAssembly and Rust</title><meta content="Learn how to run Rust programs on the web" name=description><meta content="rust, web, webassembly" name=keywords><meta content="co-authored by Carlos Chacin, Hermitter" name=author><meta content="Getting Started with WebAssembly and Rust" property=og:title><meta content=https://chacin.dev/blog/getting-started-with-webassembly-and-rust property=og:url><meta content=blog property=og:type><meta content="Learn how to run Rust programs on the web" property=og:description><meta content=https://chacin.dev/posts/getting-started-with-webassembly-and-rust/poster.png property=og:image><noscript id=sapper-head-end></noscript> </head> <body> <div id=sapper> <nav class=svelte-1gdzr3u> <ul class=svelte-1gdzr3u> <li class=svelte-1gdzr3u><a href=. class=svelte-1gdzr3u>Home</a></li> <li class=svelte-1gdzr3u><a href=blog class="svelte-1gdzr3u selected" rel=prefetch>Blog</a></li> </ul> </nav> <main class=svelte-1m3ph62> <div id=header class=svelte-1ba2qe1> <h1 class=svelte-1ba2qe1>Getting Started with WebAssembly and Rust</h1> <img alt="blog post cover image" src=../posts/getting-started-with-webassembly-and-rust/frontCover.jpg class=svelte-1ba2qe1 id=front-cover> <br> <div class="svelte-1ba2qe1 meta-data"> <p class=svelte-1ba2qe1><span class="svelte-1ba2qe1 icon-vAlign-fix"><svg class="fa-icon svelte-1dof0an" role=presentation version=1.1> </svg></span> 2020-7-26</p> <p class=svelte-1ba2qe1><span class="svelte-1ba2qe1 icon-vAlign-fix"><svg class="fa-icon svelte-1dof0an" role=presentation version=1.1> </svg></span> 13 min read</p> </div> </div> <div id=article-wrapper class=svelte-1ba2qe1> <article class="svelte-1ba2qe1 content"> <h1>Getting Started with WebAssembly & Rust</h1> <blockquote> <p>Originally written for <a href=https://blog.logrocket.com/getting-started-with-webassembly-and-rust/ >LogRocket</a> and posted here with their permission.</p> </blockquote> <p>This guide is an introduction on how to set up and work with a Rust WebAssembly environment. As for what you need to know, a basic understanding of Rust and web development should suffice.</p> <p>I initially picked up Rust because of the fantastic work the team has done in supporting and pushing WebAssembly. Their <a href=https://rustwasm.github.io/docs/book/ >official documentation</a> is a great introduction for building an example project!</p> <h1>Understanding WebAssembly</h1> <p>WebAssembly (also known as Wasm) is a binary instruction format that most browsers have started to support. This enables languages, such as Rust, C, C++ Go, etc., to be compiled and ran in a web browser.</p> <p>To clear up some misunderstandings, WebAssembly is <strong>not</strong> a replacement for JavaScript (also known as JS). Rather, it should be thought of as a way of offloading computationally heavy tasks to a more suitable language. Another benefit of this is that existing projects and libraries can now be ported to the web without needing to suffer through rewriting them in JS and the performance hits that come with that.</p> <p>For those interested in taking the Wasm specification outside the web, The <a href=https://wasi.dev/ >WebAssembly System Interface</a> (WASI) may be of interest to you!</p> <h1>Downloading the Tools</h1> <p>With everything out of the way, we can start setting up our environment! Be sure to have the following installed on your computer.</p> <ul> <li><a href=https://www.rust-lang.org/tools/install>Rust</a> (Ideally, an up to date version)</li> <li>Modern Web Browser (Internet Explorer doesn't count!)</li> <li>Your favorite text editor</li> <li>A way to host a simple webserver (to avoid the browser nagging about cross-origin requests being blocked) <ul> <li>If you have Python installed, there's a nifty command for this!</li> </ul></li> <li><a href=https://rustwasm.github.io/wasm-pack/installer/ >wasm-pack CLI</a></li> </ul> <p>Why do we need wasm-pack? To reference from Ashley Williams' <a href=https://hacks.mozilla.org/2018/04/hello-wasm-pack/ >Hello wasm-pack</a> blog post,</p> <blockquote> <p>wasm-pack is a tool for assembling and packaging Rust crates that target WebAssembly. These packages can be published to the npm Registry and used alongside other packages. This means you can use them side-by-side with JS and other packages, and in many kinds of applications.</p> </blockquote> <p>For those that don't know, Rust crates are close to what packages and libraries are for other languages. Crates work directly with Rust's build system and package manager Cargo.</p> <h1>Creating & Building a Wasm Package</h1> <p>To create a new Wasm project, we can utilize the <code>wasm-pack</code> CLI. This should be familiar for those that create Rust projects through the <code>cargo</code> CLI.</p> <pre><code class=language-sh>wasm-pack new hello-wasm
<span class=hljs-built_in>cd</span> hello-wasm
</code></pre> <p>The generated project is essentially a Rust library with boilerplate Wasm code.</p> <p><img alt="project directory from the wasm-pack build command" src=/posts/getting-started-with-webassembly-and-rust/images/project_file_structure.png></p> <p>Looking at the commands available in wasm-pack, it's clear that there's a focus for creating and publishing npm packages.</p> <pre><code>WASM-PACK SUBCOMMANDS:
    build      üèóÔ∏è  build your npm package!
    <span class=hljs-keyword>help</span>       Prints this message <span class=hljs-keyword>or</span> the <span class=hljs-keyword>help</span> <span class=hljs-keyword>of</span> the given subcommand(s)
    login      üë§  <span class=hljs-keyword>Add</span> an npm registry <span class=hljs-keyword>user</span> <span class=hljs-keyword>account</span>! (aliases: adduser, <span class=hljs-keyword>add</span>-<span class=hljs-keyword>user</span>)
    <span class=hljs-keyword>new</span>        üêë <span class=hljs-keyword>create</span> a <span class=hljs-keyword>new</span> <span class=hljs-keyword>project</span> <span class=hljs-keyword>with</span> a <span class=hljs-keyword>template</span>
    pack       üç±  <span class=hljs-keyword>create</span> a tar <span class=hljs-keyword>of</span> your npm <span class=hljs-keyword>package</span> but don<span class=hljs-string>'t publish!
    publish    üéÜ  pack up your npm package and publish!
    test       üë©‚Äçüî¨  test your wasm!
</span></code></pre> <p>Although this is great for projects that have bundlers (Webpack, Rollup, etc.), we're aiming for simple setup where we can import our Wasm binary in an HTML file. Thankfully, wasm-pack <code>build</code> has an argument to target other environments!</p> <pre><code>-t, --<span class=hljs-keyword>target</span> &lt;<span class=hljs-keyword>target</span>>        Sets the <span class=hljs-keyword>target</span> environment. [possible values: bundler, nodejs, web, no-modules]
                                [<span class=hljs-keyword>default</span>: bundler]
</code></pre> <p>The <code>web</code> target is exactly what we want! Once built, the output will create a <code>pkg</code> folder with multiple files that serve as the glue code between Wasm and JS. By the end of it, our Wasm binary will be exposed through a <a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules>JavaScript Module</a>.</p> <pre><code class=language-sh>wasm-pack build --target web
</code></pre> <h1>Running Wasm in the Browser</h1> <p>With the Rust code compiled to Wasm, we can begin going over how call it from JS. Start by creating a file called <code>index.html</code> in root of the project, and add the following:</p> <pre><code class=language-html><span class=hljs-meta>&lt;!DOCTYPE html></span>
<span class=hljs-tag>&lt;<span class=hljs-name>html</span>></span>
  <span class=hljs-tag>&lt;<span class=hljs-name>head</span>></span>
    <span class=hljs-tag>&lt;<span class=hljs-name>meta</span> <span class=hljs-attr>charset</span>=<span class=hljs-string>"utf-8"</span> /></span>
    <span class=hljs-tag>&lt;<span class=hljs-name>title</span>></span>My Wasm Project<span class=hljs-tag>&lt;/<span class=hljs-name>title</span>></span>
  <span class=hljs-tag>&lt;/<span class=hljs-name>head</span>></span>

  <span class=hljs-tag>&lt;<span class=hljs-name>body</span>></span>
    <span class=hljs-tag>&lt;<span class=hljs-name>script</span> <span class=hljs-attr>type</span>=<span class=hljs-string>"module"</span>></span><span class=javascript>
      <span class=hljs-comment>// Importing WASM for the web target requires us to call an init function provided by the default module export.</span>
      <span class=hljs-comment>// This is planned to be changed in the future.</span>
      <span class=hljs-keyword>import</span> { <span class=hljs-keyword>default</span> <span class=hljs-keyword>as</span> wasm, greet } <span class=hljs-keyword>from</span> <span class=hljs-string>"./pkg/hello_wasm.js"</span>;

      wasm().then(<span class=hljs-function>(<span class=hljs-params><span class=hljs-built_in>module</span></span>) =></span> {
        <span class=hljs-comment>// The boiler plate project comes with a `greet` function that calls:</span>
        <span class=hljs-comment>// `alert("Hello, hello-wasm!");`</span>
        greet();
      });
    </span><span class=hljs-tag>&lt;/<span class=hljs-name>script</span>></span>
  <span class=hljs-tag>&lt;/<span class=hljs-name>body</span>></span>
<span class=hljs-tag>&lt;/<span class=hljs-name>html</span>></span>
</code></pre> <p>For security reasons, browsers tend to not let you import local resources from <code>file://</code>. This prevents us from importing the Wasm binary, but an easy solution is to just start a quick webserver.</p> <p>If you have Python installed, you can use one of the following commands for this:</p> <ul> <li>Python 3: <code>python -m http.server 8000</code></li> <li>Python 2: <code>python -m SimpleHTTPServer 8000</code></li> </ul> <p>We now have Rust code ready to run in a browser! Visit http://localhost:8000 to see it live. It should be a blank page with an alert.</p> <p><img alt="Wasm project loaded on a webpage" src=/posts/getting-started-with-webassembly-and-rust/images/wasm_hello_world.png></p> <h1>Rust and JavaScript Interop</h1> <blockquote> <p>For the following code examples, you can edit the <code>index.html</code> & <code>src/lib.rs</code> files to play around with the new changes. <strong>Remember to build each time you edit your Rust code!</strong></p> </blockquote> <p>Now that you're familiar with building a project, it's time to go over how to work with it. By default, Rust doesn't directly have the ability to communicate with JS or Web APIs. This functionality is enabled through <a href=https://rustwasm.github.io/docs/wasm-bindgen/ >wasm-bindgen</a>. The project itself consists of multiple crates and a CLI tool. We've actually been using its CLI through <code>wasm-pack</code>!</p> <p>Crates from wasm-bindgen:</p> <ul> <li><a href=https://docs.rs/wasm-bindgen/ >wasm-bindgen</a>: Generates bindings and glue code between Wasm and JS.</li> <li><a href=https://docs.rs/web-sys/ >web-sys</a>: Bindings for Web APIs.</li> <li><a href=https://docs.rs/js-sys/ >js-sys</a>: Bindings for JavaScript's standard, built-in objects, including their methods and properties.</li> <li><a href=https://docs.rs/wasm-bindgen-futures>wasm_bindgen_futures</a>: Facilitates converting between <a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise>JavaScript Promises</a> to <a href=https://docs.rs/futures/0.3.5/futures/ >Rust Futures</a>.</li> </ul> <h2>Exporting Common Types</h2> <p>By importing <code>wasm_bindgen::prelude::*</code>, we're given powerful abstractions for talking to JS. Here are some I want to highlight:</p> <ul> <li><code>#[wasm_bindgen]</code>: Macro that automatically handles most of our bindings between Rust and JS.</li> <li><code>JsValue</code>: A representation for a data owned by JS.</li> <li><code>UnwrapThrowExt</code>: A trait extension for <code>Option&lt;T></code> and <code>Result&lt;T, E></code>.</li> </ul> <p>Assuming you're editing <code>src/lib.rs</code>, the examples below show how to receive/return values with Wasm. Note that variables with an underscore (like <code>_c</code>) is a Rust convention for expressing that it's unused.</p> <pre><code class=language-Rust><span class=hljs-keyword>use</span> wasm_bindgen::prelude::*;

<span class=hljs-comment>// JS doesn't have a chars type which means:</span>
<span class=hljs-comment>// - The _c argument is the first char of a JS string.</span>
<span class=hljs-comment>// - The char returned will be a JS string.</span>
<span class=hljs-meta>#[wasm_bindgen]</span>
<span class=hljs-keyword>pub</span> <span class=hljs-function><span class=hljs-keyword>fn</span> <span class=hljs-title>char_example</span></span>(_c: <span class=hljs-built_in>char</span>) -> <span class=hljs-built_in>char</span> {
    'üöÄ'
}

<span class=hljs-meta>#[wasm_bindgen]</span>
<span class=hljs-keyword>pub</span> <span class=hljs-function><span class=hljs-keyword>fn</span> <span class=hljs-title>string_example</span></span>(s: <span class=hljs-built_in>String</span>) -> <span class=hljs-built_in>String</span> {
    <span class=hljs-built_in>format!</span>(<span class=hljs-string>"Hello {}"</span>, s)
}

<span class=hljs-comment>// str cannot be used as a return type.</span>
<span class=hljs-comment>// This is because we can't return borrowed references with the wasm_bindgen macro.</span>
<span class=hljs-meta>#[wasm_bindgen]</span>
<span class=hljs-keyword>pub</span> <span class=hljs-function><span class=hljs-keyword>fn</span> <span class=hljs-title>str_example</span></span>(s: &<span class=hljs-built_in>str</span>) -> <span class=hljs-built_in>String</span> {
    <span class=hljs-built_in>format!</span>(<span class=hljs-string>"Hello {}"</span>, s)
}

<span class=hljs-meta>#[wasm_bindgen]</span>
<span class=hljs-keyword>pub</span> <span class=hljs-function><span class=hljs-keyword>fn</span> <span class=hljs-title>number_example</span></span>(n: <span class=hljs-built_in>i32</span>) -> <span class=hljs-built_in>i32</span> { <span class=hljs-comment>// assume the same for u32, usize, etc.</span>
    n+<span class=hljs-number>100</span>
}

<span class=hljs-meta>#[wasm_bindgen]</span>
<span class=hljs-keyword>pub</span> <span class=hljs-function><span class=hljs-keyword>fn</span> <span class=hljs-title>bool_example</span></span>(_b: <span class=hljs-built_in>bool</span>) -> <span class=hljs-built_in>bool</span> {
    <span class=hljs-literal>true</span>
}

<span class=hljs-comment>// `Box&lt;[JsValue]>` are the representation for a JS array object.</span>
<span class=hljs-comment>// When it comes to Js Arrays:</span>
<span class=hljs-comment>// - They are iterable.</span>
<span class=hljs-comment>// - Can contain multiple types by being of type JsValue (strictly typed arrays exist for numbers).</span>
<span class=hljs-comment>// - Don't really support N-dimensional arrays and are expensive to work with.</span>
<span class=hljs-meta>#[wasm_bindgen]</span>
<span class=hljs-keyword>pub</span> <span class=hljs-function><span class=hljs-keyword>fn</span> <span class=hljs-title>mixed_array_example</span></span>(array: <span class=hljs-built_in>Box</span>&lt;[JsValue]>) -> <span class=hljs-built_in>Box</span>&lt;[JsValue]> {
    <span class=hljs-keyword>for</span> value <span class=hljs-keyword>in</span> array.iter() {
        <span class=hljs-comment>// compute things...</span>
    }

    <span class=hljs-built_in>vec!</span>[
        <span class=hljs-string>"Hello"</span>.into(),
        <span class=hljs-number>512</span>.into(),
        JsValue::NULL,
        JsValue::UNDEFINED,
        <span class=hljs-number>61.20</span>.into(),
    ]
    .into_boxed_slice()
}

<span class=hljs-comment>// Typed arrays are only available for number types.</span>
<span class=hljs-comment>// For example, the function below will return a JS Int32Array type.</span>
<span class=hljs-meta>#[wasm_bindgen]</span>
<span class=hljs-keyword>pub</span> <span class=hljs-function><span class=hljs-keyword>fn</span> <span class=hljs-title>typed_array_example</span></span>(_array: <span class=hljs-built_in>Box</span>&lt;[<span class=hljs-built_in>i32</span>]>) -> <span class=hljs-built_in>Box</span>&lt;[<span class=hljs-built_in>i32</span>]> {
    <span class=hljs-built_in>vec!</span>[<span class=hljs-number>1</span>, <span class=hljs-number>2</span>, <span class=hljs-number>3</span>, <span class=hljs-number>4</span>, <span class=hljs-number>5</span>, <span class=hljs-number>6</span>, <span class=hljs-number>7</span>].into_boxed_slice()
}

<span class=hljs-comment>// When it comes to Option:</span>
<span class=hljs-comment>// - Some returns the value inside.</span>
<span class=hljs-comment>// - None returns a JS undefined.</span>
<span class=hljs-meta>#[wasm_bindgen(catch)]</span>
<span class=hljs-keyword>pub</span> <span class=hljs-function><span class=hljs-keyword>fn</span> <span class=hljs-title>option_example</span></span>() -> <span class=hljs-built_in>Option</span>&lt;<span class=hljs-built_in>i32</span>> {
    <span class=hljs-literal>None</span>
}

<span class=hljs-comment>// When it comes to Result</span>
<span class=hljs-comment>// - Result&lt;T, JsValue> is the only supported signature. T must be convertible to a JsValue.</span>
<span class=hljs-comment>// - #[wasm_bindgen(catch)] must be used when returning a result.</span>
<span class=hljs-comment>// - Err will be equivalent to a JS thrown error.</span>
<span class=hljs-comment>// - Ok will return the value inside.</span>
<span class=hljs-meta>#[wasm_bindgen]</span>
<span class=hljs-keyword>pub</span> <span class=hljs-function><span class=hljs-keyword>fn</span> <span class=hljs-title>result_example</span></span>() -> <span class=hljs-built_in>Result</span>&lt;<span class=hljs-built_in>i32</span>, JsValue> {
    <span class=hljs-comment>// With the wasm prelude imported, we can convert most common types by calling .into()</span>
    <span class=hljs-literal>Err</span>(<span class=hljs-string>"Look Pa, I'm throwing a JS error!"</span>.into())
}
</code></pre> <p>Once the project is built again, these functions can be directly used in our web page. Feel free to play around and print the values returned.</p> <pre><code class=language-html><span class=hljs-tag>&lt;<span class=hljs-name>script</span> <span class=hljs-attr>type</span>=<span class=hljs-string>"module"</span>></span><span class=javascript>
  <span class=hljs-keyword>import</span> * <span class=hljs-keyword>as</span> wasm <span class=hljs-keyword>from</span> <span class=hljs-string>"./pkg/hello_wasm.js"</span>;

  wasm.default().then(<span class=hljs-function>(<span class=hljs-params><span class=hljs-built_in>module</span></span>) =></span> {
    wasm.char_example(<span class=hljs-string>"R"</span>);
    wasm.string_example(<span class=hljs-string>"Jane"</span>);
    wasm.str_example(<span class=hljs-string>"John"</span>);
    wasm.number_example(<span class=hljs-number>28</span>);
    wasm.mixed_array_example([<span class=hljs-number>2</span>, <span class=hljs-literal>null</span>, <span class=hljs-literal>undefined</span>, <span class=hljs-string>"Hola"</span>, <span class=hljs-literal>true</span>]);
    wasm.typed_array_example([<span class=hljs-number>1</span>, <span class=hljs-number>2</span>, <span class=hljs-number>3</span>, <span class=hljs-number>4</span>, <span class=hljs-number>5</span>, <span class=hljs-number>6</span>, <span class=hljs-number>7</span>, <span class=hljs-number>8</span>, <span class=hljs-number>9</span>, <span class=hljs-number>10</span>]);
    wasm.option_example();
    wasm.result_example();
  });
</span><span class=hljs-tag>&lt;/<span class=hljs-name>script</span>></span>
</code></pre> <h2>Exporting Structs & Enums</h2> <p>Expanding on what was explored above, enums and structs are a fairly simple export. Although there are some restrictions, the syntax should still feel like day-to-day Rust.</p> <pre><code class=language-rust><span class=hljs-keyword>use</span> wasm_bindgen::prelude::*;

<span class=hljs-comment>// When it comes to Enums:</span>
<span class=hljs-comment>// - They  are C styled.</span>
<span class=hljs-comment>// - JS represents them through an object with a number for each variant.</span>
<span class=hljs-meta>#[wasm_bindgen]</span>
<span class=hljs-keyword>pub</span> <span class=hljs-class><span class=hljs-keyword>enum</span> <span class=hljs-title>ExampleEnum</span></span> {
    Yes,
    No,
}

<span class=hljs-meta>#[wasm_bindgen]</span>
<span class=hljs-keyword>pub</span> <span class=hljs-function><span class=hljs-keyword>fn</span> <span class=hljs-title>verify_enum_choice</span></span>(choice: ExampleEnum) -> <span class=hljs-built_in>bool</span> {
    <span class=hljs-keyword>match</span> choice {
        ExampleEnum::Yes => <span class=hljs-literal>true</span>,
        ExampleEnum::No => <span class=hljs-literal>false</span>,
    }
}

<span class=hljs-comment>// When it comes to Structs:</span>
<span class=hljs-comment>// - Cannot contain lifetimes or type parameters.</span>
<span class=hljs-comment>// - Each field value must impl the Copy trait.</span>
<span class=hljs-meta>#[wasm_bindgen]</span>
<span class=hljs-keyword>pub</span> <span class=hljs-class><span class=hljs-keyword>struct</span> <span class=hljs-title>ExampleStruct</span></span> {
    <span class=hljs-keyword>pub</span> value: <span class=hljs-built_in>i32</span>,
}

<span class=hljs-comment>// For struct impl, we have the option for struct methods and type-level functions.</span>
<span class=hljs-comment>// JS handles structs by creating a JS object with a pointer (i.o.w. we can use references!).</span>
<span class=hljs-meta>#[wasm_bindgen]</span>
<span class=hljs-keyword>impl</span> ExampleStruct {
    <span class=hljs-keyword>pub</span> <span class=hljs-function><span class=hljs-keyword>fn</span> <span class=hljs-title>new</span></span>(value: <span class=hljs-built_in>i32</span>) -> ExampleStruct {
        ExampleStruct { value }
    }

    <span class=hljs-keyword>pub</span> <span class=hljs-function><span class=hljs-keyword>fn</span> <span class=hljs-title>read_method</span></span>(&<span class=hljs-keyword>self</span>) -> <span class=hljs-built_in>i32</span> {
        <span class=hljs-keyword>self</span>.value
    }

    <span class=hljs-keyword>pub</span> <span class=hljs-function><span class=hljs-keyword>fn</span> <span class=hljs-title>write_method</span></span>(&<span class=hljs-keyword>mut</span> <span class=hljs-keyword>self</span>, value: <span class=hljs-built_in>i32</span>) {
        <span class=hljs-keyword>self</span>.value = value;
    }

    <span class=hljs-keyword>pub</span> <span class=hljs-function><span class=hljs-keyword>fn</span> <span class=hljs-title>transfer_ownership</span></span>(<span class=hljs-keyword>self</span>) -> ExampleStruct {
        <span class=hljs-keyword>self</span>
    }
}
</code></pre> <p>Now we can import the struct and enum directly into our JS code. Once a struct is instantiated, we can call its Wasm compatible methods.</p> <pre><code class=language-html><span class=hljs-tag>&lt;<span class=hljs-name>script</span> <span class=hljs-attr>type</span>=<span class=hljs-string>"module"</span>></span><span class=javascript>
  <span class=hljs-keyword>import</span> * <span class=hljs-keyword>as</span> wasm <span class=hljs-keyword>from</span> <span class=hljs-string>"./pkg/hello_wasm.js"</span>;

  wasm.default().then(<span class=hljs-function>(<span class=hljs-params><span class=hljs-built_in>module</span></span>) =></span> {
    <span class=hljs-comment>// Enum \\</span>
    <span class=hljs-keyword>let</span> rustEnum = wasm.ExampleEnum.Yes;
    <span class=hljs-built_in>console</span>.log(wasm.verify_enum_choice(rustEnum));

    <span class=hljs-comment>// Struct \\</span>
    <span class=hljs-keyword>let</span> rustStruct = wasm.ExampleStruct.new(<span class=hljs-number>6</span>);
    <span class=hljs-built_in>console</span>.log(rustStruct); <span class=hljs-comment>// this will contain a pointer</span>
    <span class=hljs-built_in>console</span>.log(rustStruct.value);

    rustStruct.write_method(<span class=hljs-number>200</span>);
    <span class=hljs-built_in>console</span>.log(rustStruct.read_method());

    <span class=hljs-keyword>let</span> newRustStruct = rustStruct.transfer_ownership();
    rustStruct.read_method(); <span class=hljs-comment>// rustStruct is now invalid. An error will throw.</span>
  });
</span><span class=hljs-tag>&lt;/<span class=hljs-name>script</span>></span>
</code></pre> <p>We've provided an output image of the script below to better show how these types work. Notice how the enums and structs are represented in JS.</p> <p><img alt="Web console output of Rust struct and enum exports" src=/posts/getting-started-with-webassembly-and-rust/images/enum_and_struct_example_log.png></p> <h2>Manually Creating Bindings</h2> <p>The <code>wasm-bindgen</code> crate gives us powerful tooling for talking to JS. However, there are no direct bindings for the JS standard or Web APIs. That's where <code>web-sys</code> and <code>js-sys</code> come in. Both crates provide ready made bindings that give us a standard interface to work with.</p> <p>Of course, these crates don't cover everything and we need to create our own bindings for anything missing. A common example is wrapping over custom JS classes and functions. When you first opened <code>src/lib.rs</code> you might've noticed a binding was created for the <code>alert()</code> function.</p> <p>To see how to create our own custom bindings, we'll first look over the JS code we want Rust to bind for.</p> <pre><code class=language-html><span class=hljs-comment>&lt;!--
  For simplicity, we'll add a class declaration to the global namespace.
  The goal, from rust, is to create this class, call a method, and get/set a property.
--></span>
<span class=hljs-tag>&lt;<span class=hljs-name>script</span>></span><span class=javascript>
  <span class=hljs-class><span class=hljs-keyword>class</span> <span class=hljs-title>Coordinate</span> </span>{
    <span class=hljs-keyword>constructor</span>(x, y) {
      <span class=hljs-keyword>this</span>.x = x;
      <span class=hljs-keyword>this</span>.y = y;
    }

    printValues() {
      <span class=hljs-keyword>return</span> <span class=hljs-string>`(x:<span class=hljs-subst>${<span class=hljs-keyword>this</span>.x}</span> y:<span class=hljs-subst>${<span class=hljs-keyword>this</span>.y}</span>)`</span>;
    }
  }
</span><span class=hljs-tag>&lt;/<span class=hljs-name>script</span>></span>

<span class=hljs-tag>&lt;<span class=hljs-name>script</span> <span class=hljs-attr>type</span>=<span class=hljs-string>"module"</span>></span><span class=javascript>
  <span class=hljs-keyword>import</span> * <span class=hljs-keyword>as</span> wasm <span class=hljs-keyword>from</span> <span class=hljs-string>"./pkg/hello_wasm.js"</span>;

  wasm.default().then(<span class=hljs-function>(<span class=hljs-params><span class=hljs-built_in>module</span></span>) =></span> {
    wasm.manual_bindings_example();
  });
</span><span class=hljs-tag>&lt;/<span class=hljs-name>script</span>></span>
</code></pre> <p>On top of binding the Coordinates class, below are some examples on how to do the same for various JS functions.</p> <pre><code class=language-Rust><span class=hljs-keyword>use</span> wasm_bindgen::prelude::*;

<span class=hljs-comment>// Although we're using what's in the global namespace, we can also import from other modules.</span>
<span class=hljs-comment>// #[wasm_bindgen(module = "./bar")]</span>
<span class=hljs-comment>// extern "C" {}</span>

<span class=hljs-comment>// Binding JS involves a bit of boilerplate because we have to specify each name</span>
<span class=hljs-comment>// and signature to bind.</span>
<span class=hljs-meta>#[wasm_bindgen]</span>
<span class=hljs-keyword>extern</span> <span class=hljs-string>"C"</span> {
    <span class=hljs-comment>// Bindings must be named as their JS equivalent</span>
    <span class=hljs-function><span class=hljs-keyword>fn</span> <span class=hljs-title>alert</span></span>(s: &<span class=hljs-built_in>str</span>);

    <span class=hljs-comment>// A different name can be specified as long as the original name is passed to the macro.</span>
    <span class=hljs-meta>#[wasm_bindgen(js_name = prompt)]</span>
    <span class=hljs-function><span class=hljs-keyword>fn</span> <span class=hljs-title>ask</span></span>(s: &<span class=hljs-built_in>str</span>) -> <span class=hljs-built_in>String</span>;

    <span class=hljs-comment>// Functions can be from any js namespace.</span>
    <span class=hljs-meta>#[wasm_bindgen(js_namespace = console)]</span>
    <span class=hljs-function><span class=hljs-keyword>fn</span> <span class=hljs-title>log</span></span>(s: &<span class=hljs-built_in>str</span>);

    <span class=hljs-comment>// Using a different name allows us to specify various signatures.</span>
    <span class=hljs-meta>#[wasm_bindgen(js_namespace = console, js_name = log)]</span>
    <span class=hljs-function><span class=hljs-keyword>fn</span> <span class=hljs-title>log_num</span></span>(n: <span class=hljs-built_in>i32</span>);

    <span class=hljs-comment>//* JS Class example *\\</span>
    <span class=hljs-comment>// The process is a little verbose because create a binding for</span>
    <span class=hljs-comment>// each part of the class we want (class name, constructor, methods, setters, getters).</span>
    <span class=hljs-class><span class=hljs-keyword>type</span> <span class=hljs-title>Coordinate</span></span>;

    <span class=hljs-meta>#[wasm_bindgen(constructor)]</span>
    <span class=hljs-function><span class=hljs-keyword>fn</span> <span class=hljs-title>new</span></span>(x: <span class=hljs-built_in>i32</span>, y: <span class=hljs-built_in>i32</span>) -> Coordinate;

    <span class=hljs-comment>// methods must match the naming in the class declaration.</span>
    <span class=hljs-meta>#[wasm_bindgen(method)]</span>
    <span class=hljs-function><span class=hljs-keyword>fn</span> <span class=hljs-title>printValues</span></span>(this: &Coordinate) -> <span class=hljs-built_in>String</span>;

    <span class=hljs-comment>// getters are named as the property we want.</span>
    <span class=hljs-meta>#[wasm_bindgen(getter, method)]</span>
    <span class=hljs-function><span class=hljs-keyword>fn</span> <span class=hljs-title>x</span></span>(this: &Coordinate) -> <span class=hljs-built_in>i32</span>;

    <span class=hljs-comment>// setters are named the same as getters but with a `set_` prefix.</span>
    <span class=hljs-meta>#[wasm_bindgen(setter, method)]</span>
    <span class=hljs-function><span class=hljs-keyword>fn</span> <span class=hljs-title>set_x</span></span>(this: &Coordinate, x: <span class=hljs-built_in>i32</span>);
}

<span class=hljs-meta>#[wasm_bindgen]</span>
<span class=hljs-keyword>pub</span> <span class=hljs-function><span class=hljs-keyword>fn</span> <span class=hljs-title>manual_bindings_example</span></span>() {
    alert(<span class=hljs-string>"Hey buddy!"</span>);
    log(&ask(<span class=hljs-string>"Tell me about your day!"</span>));

    <span class=hljs-keyword>let</span> coordinates = Coordinate::new(-<span class=hljs-number>4</span>, <span class=hljs-number>15</span>);
    log_num(coordinates.x()); <span class=hljs-comment>// prints -4</span>

    coordinates.set_x(coordinates.x() * <span class=hljs-number>2</span>);
    log(&coordinates.printValues()); <span class=hljs-comment>// prints (-8, 15)</span>
}
</code></pre> <p><img alt="Browser and console output of the manually created Rust Wasm bindings" src=/posts/getting-started-with-webassembly-and-rust/images/manual_bindings_example.gif></p> <h2>Interacting with Web APIs</h2> <p>The majority essential web APIs are provided and documented by the <code>web-sys</code> crate. After specifying what APIs we want, we can:</p> <ul> <li>Edit HTML elements.</li> <li>Add event listeners.</li> <li>Print to the web console.</li> <li>Draw on a canvas.</li> <li>And more!</li> </ul> <p>Since the list is extensive, we'll simply cover how to set up and use this create. Add the following to the project's <code>Cargo.toml</code> and then specify each web API you want to use.</p> <pre><code class=language-toml><span class=hljs-section>[dependencies]</span>
<span class=hljs-attr>web-sys</span> = { version = <span class=hljs-string>"0.3.39"</span>, features = [<span class=hljs-string>'console'</span>] }
</code></pre> <pre><code class=language-rust><span class=hljs-keyword>use</span> wasm_bindgen::prelude::*;
<span class=hljs-keyword>use</span> web_sys::console;

<span class=hljs-meta>#[wasm_bindgen]</span>
<span class=hljs-keyword>pub</span> <span class=hljs-function><span class=hljs-keyword>fn</span> <span class=hljs-title>print_things</span></span>() {
  <span class=hljs-comment>// console has multiple log_x functions that represent how many items are being printed.</span>
  <span class=hljs-comment>// log_x takes in a reference to a JsValue so we need to convert the values we want to print.</span>
  console::log_1(&<span class=hljs-string>"Printing from Rust!!"</span>.into());
  console::log_2(&<span class=hljs-string>"Numbers: "</span>.into(), &<span class=hljs-number>1234</span>.into());
}
</code></pre> <p><code>web-sys</code> Resources:</p> <ul> <li><a href=https://docs.rs/crate/web-sys/0.3.39/source/Cargo.toml>Available Crate features</a>: The full list of Web APIs.</li> <li><a href=https://rustwasm.github.io/docs/wasm-bindgen/examples/dom.html>Official Example</a>: Covers basic DOM manipulation.</li> </ul> <p>Remember to take a look at the <code>js-sys</code> crate if you find yourself needing to import types and functions from standard JS.</p> <h1>Closing thoughts</h1> <p>Although we couldn't cover everything (Wasm has more to offer than can fit in just one blog post), I hope this guide was able to jump start your journey into WebAssembly! I highly encourage going though the <a href=https://rustwasm.github.io/docs/wasm-bindgen/ >wasm-bindgen docs</a> to go over what we couldn't cover here. It covers more in-depth examples and important topics like <a href=https://rustwasm.github.io/docs/wasm-bindgen/reference/arbitrary-data-with-serde.html>Sending Arbitrary Data Between JS & Rust</a>. Keep in mind that the Rust WebAssembly ecosystem is still growing and it's only going to get better from here!</p> </article> </div> <div id=comments class=svelte-1ba2qe1> <div id=disqus_thread></div> <noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript> </div> </main></div> <script>__SAPPER__={baseUrl:"",preloaded:[void 0,null,{post:{title:"Getting Started with WebAssembly and Rust",poster:"posts\u002Fgetting-started-with-webassembly-and-rust\u002Fposter.png",frontCover:"..\u002Fposts\u002Fgetting-started-with-webassembly-and-rust\u002FfrontCover.jpg",keywords:"rust, web, webassembly",description:"Learn how to run Rust programs on the web",slug:"getting-started-with-webassembly-and-rust",html:"\u003Ch1\u003EGetting Started with WebAssembly &amp; Rust\u003C\u002Fh1\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003EOriginally written for \u003Ca href=\"https:\u002F\u002Fblog.logrocket.com\u002Fgetting-started-with-webassembly-and-rust\u002F\"\u003ELogRocket\u003C\u002Fa\u003E and posted here with their permission.\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003EThis guide is an introduction on how to set up and work with a Rust WebAssembly environment. As for what you need to know, a basic understanding of Rust and web development should suffice.\u003C\u002Fp\u003E\n\u003Cp\u003EI initially picked up Rust because of the fantastic work the team has done in supporting and pushing WebAssembly. Their \u003Ca href=\"https:\u002F\u002Frustwasm.github.io\u002Fdocs\u002Fbook\u002F\"\u003Eofficial documentation\u003C\u002Fa\u003E is a great introduction for building an example project!\u003C\u002Fp\u003E\n\u003Ch1\u003EUnderstanding WebAssembly\u003C\u002Fh1\u003E\n\u003Cp\u003EWebAssembly (also known as Wasm) is a binary instruction format that most browsers have started to support. This enables languages, such as Rust, C, C++ Go, etc., to be compiled and ran in a web browser.\u003C\u002Fp\u003E\n\u003Cp\u003ETo clear up some misunderstandings, WebAssembly is \u003Cstrong\u003Enot\u003C\u002Fstrong\u003E a replacement for JavaScript (also known as JS). Rather, it should be thought of as a way of offloading computationally heavy tasks to a more suitable language. Another benefit of this is that existing projects and libraries can now be ported to the web without needing to suffer through rewriting them in JS and the performance hits that come with that.\u003C\u002Fp\u003E\n\u003Cp\u003EFor those interested in taking the Wasm specification outside the web, The \u003Ca href=\"https:\u002F\u002Fwasi.dev\u002F\"\u003EWebAssembly System Interface\u003C\u002Fa\u003E (WASI) may be of interest to you!\u003C\u002Fp\u003E\n\u003Ch1\u003EDownloading the Tools\u003C\u002Fh1\u003E\n\u003Cp\u003EWith everything out of the way, we can start setting up our environment! Be sure to have the following installed on your computer.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fwww.rust-lang.org\u002Ftools\u002Finstall\"\u003ERust\u003C\u002Fa\u003E (Ideally, an up to date version)\u003C\u002Fli\u003E\n\u003Cli\u003EModern Web Browser (Internet Explorer doesn't count!)\u003C\u002Fli\u003E\n\u003Cli\u003EYour favorite text editor\u003C\u002Fli\u003E\n\u003Cli\u003EA way to host a simple webserver (to avoid the browser nagging about cross-origin requests being blocked)\n\u003Cul\u003E\n\u003Cli\u003EIf you have Python installed, there's a nifty command for this!\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Frustwasm.github.io\u002Fwasm-pack\u002Finstaller\u002F\"\u003Ewasm-pack CLI\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003EWhy do we need wasm-pack? To reference from Ashley Williams' \u003Ca href=\"https:\u002F\u002Fhacks.mozilla.org\u002F2018\u002F04\u002Fhello-wasm-pack\u002F\"\u003EHello wasm-pack\u003C\u002Fa\u003E blog post,\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003Ewasm-pack is a tool for assembling and packaging Rust crates that target WebAssembly. These packages can be published to the npm Registry and used alongside other packages. This means you can use them side-by-side with JS and other packages, and in many kinds of applications.\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003EFor those that don't know, Rust crates are close to what packages and libraries are for other languages. Crates work directly with Rust's build system and package manager Cargo.\u003C\u002Fp\u003E\n\u003Ch1\u003ECreating &amp; Building a Wasm Package\u003C\u002Fh1\u003E\n\u003Cp\u003ETo create a new Wasm project, we can utilize the \u003Ccode\u003Ewasm-pack\u003C\u002Fcode\u003E CLI. This should be familiar for those that create Rust projects through the \u003Ccode\u003Ecargo\u003C\u002Fcode\u003E CLI.\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-sh\"\u003Ewasm-pack new hello-wasm\n\u003Cspan class=\"hljs-built_in\"\u003Ecd\u003C\u002Fspan\u003E hello-wasm\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EThe generated project is essentially a Rust library with boilerplate Wasm code.\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"\u002Fposts\u002Fgetting-started-with-webassembly-and-rust\u002Fimages\u002Fproject_file_structure.png\" alt=\"project directory from the wasm-pack build command\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003ELooking at the commands available in wasm-pack, it's clear that there's a focus for creating and publishing npm packages.\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003EWASM-PACK SUBCOMMANDS:\n    build      üèóÔ∏è  build your npm package!\n    \u003Cspan class=\"hljs-keyword\"\u003Ehelp\u003C\u002Fspan\u003E       Prints this message \u003Cspan class=\"hljs-keyword\"\u003Eor\u003C\u002Fspan\u003E the \u003Cspan class=\"hljs-keyword\"\u003Ehelp\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eof\u003C\u002Fspan\u003E the given subcommand(s)\n    login      üë§  \u003Cspan class=\"hljs-keyword\"\u003EAdd\u003C\u002Fspan\u003E an npm registry \u003Cspan class=\"hljs-keyword\"\u003Euser\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eaccount\u003C\u002Fspan\u003E! (aliases: adduser, \u003Cspan class=\"hljs-keyword\"\u003Eadd\u003C\u002Fspan\u003E-\u003Cspan class=\"hljs-keyword\"\u003Euser\u003C\u002Fspan\u003E)\n    \u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E        üêë \u003Cspan class=\"hljs-keyword\"\u003Ecreate\u003C\u002Fspan\u003E a \u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eproject\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Ewith\u003C\u002Fspan\u003E a \u003Cspan class=\"hljs-keyword\"\u003Etemplate\u003C\u002Fspan\u003E\n    pack       üç±  \u003Cspan class=\"hljs-keyword\"\u003Ecreate\u003C\u002Fspan\u003E a tar \u003Cspan class=\"hljs-keyword\"\u003Eof\u003C\u002Fspan\u003E your npm \u003Cspan class=\"hljs-keyword\"\u003Epackage\u003C\u002Fspan\u003E but don\u003Cspan class=\"hljs-string\"\u003E't publish!\n    publish    üéÜ  pack up your npm package and publish!\n    test       üë©‚Äçüî¨  test your wasm!\n\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EAlthough this is great for projects that have bundlers (Webpack, Rollup, etc.), we're aiming for simple setup where we can import our Wasm binary in an HTML file. Thankfully, wasm-pack \u003Ccode\u003Ebuild\u003C\u002Fcode\u003E has an argument to target other environments!\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003E-t, --\u003Cspan class=\"hljs-keyword\"\u003Etarget\u003C\u002Fspan\u003E &lt;\u003Cspan class=\"hljs-keyword\"\u003Etarget\u003C\u002Fspan\u003E&gt;        Sets the \u003Cspan class=\"hljs-keyword\"\u003Etarget\u003C\u002Fspan\u003E environment. [possible values: bundler, nodejs, web, no-modules]\n                                [\u003Cspan class=\"hljs-keyword\"\u003Edefault\u003C\u002Fspan\u003E: bundler]\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EThe \u003Ccode\u003Eweb\u003C\u002Fcode\u003E target is exactly what we want! Once built, the output will create a \u003Ccode\u003Epkg\u003C\u002Fcode\u003E folder with multiple files that serve as the glue code between Wasm and JS. By the end of it, our Wasm binary will be exposed through a \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FJavaScript\u002FGuide\u002FModules\"\u003EJavaScript Module\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-sh\"\u003Ewasm-pack build --target web\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch1\u003ERunning Wasm in the Browser\u003C\u002Fh1\u003E\n\u003Cp\u003EWith the Rust code compiled to Wasm, we can begin going over how call it from JS. Start by creating a file called \u003Ccode\u003Eindex.html\u003C\u002Fcode\u003E in root of the project, and add the following:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-html\"\u003E\u003Cspan class=\"hljs-meta\"\u003E&lt;!DOCTYPE html&gt;\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Ehtml\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Ehead\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Emeta\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-attr\"\u003Echarset\u003C\u002Fspan\u003E=\u003Cspan class=\"hljs-string\"\u003E\"utf-8\"\u003C\u002Fspan\u003E \u002F&gt;\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Etitle\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003EMy Wasm Project\u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Etitle\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Ehead\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\n\n  \u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Ebody\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Escript\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-attr\"\u003Etype\u003C\u002Fspan\u003E=\u003Cspan class=\"hljs-string\"\u003E\"module\"\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\u003Cspan class=\"javascript\"\u003E\n      \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F Importing WASM for the web target requires us to call an init function provided by the default module export.\u003C\u002Fspan\u003E\n      \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F This is planned to be changed in the future.\u003C\u002Fspan\u003E\n      \u003Cspan class=\"hljs-keyword\"\u003Eimport\u003C\u002Fspan\u003E { \u003Cspan class=\"hljs-keyword\"\u003Edefault\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eas\u003C\u002Fspan\u003E wasm, greet } \u003Cspan class=\"hljs-keyword\"\u003Efrom\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003E\".\u002Fpkg\u002Fhello_wasm.js\"\u003C\u002Fspan\u003E;\n\n      wasm().then(\u003Cspan class=\"hljs-function\"\u003E(\u003Cspan class=\"hljs-params\"\u003E\u003Cspan class=\"hljs-built_in\"\u003Emodule\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E) =&gt;\u003C\u002Fspan\u003E {\n        \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F The boiler plate project comes with a `greet` function that calls:\u003C\u002Fspan\u003E\n        \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F `alert(\"Hello, hello-wasm!\");`\u003C\u002Fspan\u003E\n        greet();\n      });\n    \u003C\u002Fspan\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Escript\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Ebody\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Ehtml\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EFor security reasons, browsers tend to not let you import local resources from \u003Ccode\u003Efile:\u002F\u002F\u003C\u002Fcode\u003E. This prevents us from importing the Wasm binary, but an easy solution is to just start a quick webserver.\u003C\u002Fp\u003E\n\u003Cp\u003EIf you have Python installed, you can use one of the following commands for this:\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EPython 3: \u003Ccode\u003Epython -m http.server 8000\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003EPython 2: \u003Ccode\u003Epython -m SimpleHTTPServer 8000\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003EWe now have Rust code ready to run in a browser! Visit http:\u002F\u002Flocalhost:8000 to see it live. It should be a blank page with an alert.\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"\u002Fposts\u002Fgetting-started-with-webassembly-and-rust\u002Fimages\u002Fwasm_hello_world.png\" alt=\"Wasm project loaded on a webpage\"\u003E\u003C\u002Fp\u003E\n\u003Ch1\u003ERust and JavaScript Interop\u003C\u002Fh1\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003EFor the following code examples, you can edit the \u003Ccode\u003Eindex.html\u003C\u002Fcode\u003E &amp; \u003Ccode\u003Esrc\u002Flib.rs\u003C\u002Fcode\u003E files to play around with the new changes. \u003Cstrong\u003ERemember to build each time you edit your Rust code!\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003ENow that you're familiar with building a project, it's time to go over how to work with it. By default, Rust doesn't directly have the ability to communicate with JS or Web APIs. This functionality is enabled through \u003Ca href=\"https:\u002F\u002Frustwasm.github.io\u002Fdocs\u002Fwasm-bindgen\u002F\"\u003Ewasm-bindgen\u003C\u002Fa\u003E. The project itself consists of multiple crates and a CLI tool. We've actually been using its CLI through \u003Ccode\u003Ewasm-pack\u003C\u002Fcode\u003E!\u003C\u002Fp\u003E\n\u003Cp\u003ECrates from wasm-bindgen:\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fdocs.rs\u002Fwasm-bindgen\u002F\"\u003Ewasm-bindgen\u003C\u002Fa\u003E: Generates bindings and glue code between Wasm and JS.\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fdocs.rs\u002Fweb-sys\u002F\"\u003Eweb-sys\u003C\u002Fa\u003E: Bindings for Web APIs.\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fdocs.rs\u002Fjs-sys\u002F\"\u003Ejs-sys\u003C\u002Fa\u003E: Bindings for JavaScript's standard, built-in objects, including their methods and properties.\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fdocs.rs\u002Fwasm-bindgen-futures\"\u003Ewasm_bindgen_futures\u003C\u002Fa\u003E: Facilitates converting between\n\u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FJavaScript\u002FReference\u002FGlobal_Objects\u002FPromise\"\u003EJavaScript Promises\u003C\u002Fa\u003E to \u003Ca href=\"https:\u002F\u002Fdocs.rs\u002Ffutures\u002F0.3.5\u002Ffutures\u002F\"\u003ERust Futures\u003C\u002Fa\u003E.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch2\u003EExporting Common Types\u003C\u002Fh2\u003E\n\u003Cp\u003EBy importing \u003Ccode\u003Ewasm_bindgen::prelude::*\u003C\u002Fcode\u003E, we're given powerful abstractions for talking to JS. Here are some I want to highlight:\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ccode\u003E#[wasm_bindgen]\u003C\u002Fcode\u003E: Macro that automatically handles most of our bindings between Rust and JS.\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003EJsValue\u003C\u002Fcode\u003E: A representation for a data owned by JS.\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003EUnwrapThrowExt\u003C\u002Fcode\u003E: A trait extension for\n\u003Ccode\u003EOption&lt;T&gt;\u003C\u002Fcode\u003E and \u003Ccode\u003EResult&lt;T, E&gt;\u003C\u002Fcode\u003E.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003EAssuming you're editing \u003Ccode\u003Esrc\u002Flib.rs\u003C\u002Fcode\u003E, the examples below show how to receive\u002Freturn values with Wasm. Note that variables with an underscore (like \u003Ccode\u003E_c\u003C\u002Fcode\u003E) is a Rust convention for expressing that it's unused.\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-Rust\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Euse\u003C\u002Fspan\u003E wasm_bindgen::prelude::*;\n\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F JS doesn't have a chars type which means:\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F - The _c argument is the first char of a JS string.\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F - The char returned will be a JS string.\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-meta\"\u003E#[wasm_bindgen]\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003Epub\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Echar_example\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E(_c: \u003Cspan class=\"hljs-built_in\"\u003Echar\u003C\u002Fspan\u003E) -&gt; \u003Cspan class=\"hljs-built_in\"\u003Echar\u003C\u002Fspan\u003E {\n    'üöÄ'\n}\n\n\u003Cspan class=\"hljs-meta\"\u003E#[wasm_bindgen]\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003Epub\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Estring_example\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E(s: \u003Cspan class=\"hljs-built_in\"\u003EString\u003C\u002Fspan\u003E) -&gt; \u003Cspan class=\"hljs-built_in\"\u003EString\u003C\u002Fspan\u003E {\n    \u003Cspan class=\"hljs-built_in\"\u003Eformat!\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-string\"\u003E\"Hello {}\"\u003C\u002Fspan\u003E, s)\n}\n\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F str cannot be used as a return type.\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F This is because we can't return borrowed references with the wasm_bindgen macro.\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-meta\"\u003E#[wasm_bindgen]\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003Epub\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Estr_example\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E(s: &amp;\u003Cspan class=\"hljs-built_in\"\u003Estr\u003C\u002Fspan\u003E) -&gt; \u003Cspan class=\"hljs-built_in\"\u003EString\u003C\u002Fspan\u003E {\n    \u003Cspan class=\"hljs-built_in\"\u003Eformat!\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-string\"\u003E\"Hello {}\"\u003C\u002Fspan\u003E, s)\n}\n\n\u003Cspan class=\"hljs-meta\"\u003E#[wasm_bindgen]\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003Epub\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Enumber_example\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E(n: \u003Cspan class=\"hljs-built_in\"\u003Ei32\u003C\u002Fspan\u003E) -&gt; \u003Cspan class=\"hljs-built_in\"\u003Ei32\u003C\u002Fspan\u003E { \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F assume the same for u32, usize, etc.\u003C\u002Fspan\u003E\n    n+\u003Cspan class=\"hljs-number\"\u003E100\u003C\u002Fspan\u003E\n}\n\n\u003Cspan class=\"hljs-meta\"\u003E#[wasm_bindgen]\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003Epub\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Ebool_example\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E(_b: \u003Cspan class=\"hljs-built_in\"\u003Ebool\u003C\u002Fspan\u003E) -&gt; \u003Cspan class=\"hljs-built_in\"\u003Ebool\u003C\u002Fspan\u003E {\n    \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E\n}\n\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F `Box&lt;[JsValue]&gt;` are the representation for a JS array object.\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F When it comes to Js Arrays:\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F - They are iterable.\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F - Can contain multiple types by being of type JsValue (strictly typed arrays exist for numbers).\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F - Don't really support N-dimensional arrays and are expensive to work with.\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-meta\"\u003E#[wasm_bindgen]\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003Epub\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Emixed_array_example\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E(array: \u003Cspan class=\"hljs-built_in\"\u003EBox\u003C\u002Fspan\u003E&lt;[JsValue]&gt;) -&gt; \u003Cspan class=\"hljs-built_in\"\u003EBox\u003C\u002Fspan\u003E&lt;[JsValue]&gt; {\n    \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E value \u003Cspan class=\"hljs-keyword\"\u003Ein\u003C\u002Fspan\u003E array.iter() {\n        \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F compute things...\u003C\u002Fspan\u003E\n    }\n\n    \u003Cspan class=\"hljs-built_in\"\u003Evec!\u003C\u002Fspan\u003E[\n        \u003Cspan class=\"hljs-string\"\u003E\"Hello\"\u003C\u002Fspan\u003E.into(),\n        \u003Cspan class=\"hljs-number\"\u003E512\u003C\u002Fspan\u003E.into(),\n        JsValue::NULL,\n        JsValue::UNDEFINED,\n        \u003Cspan class=\"hljs-number\"\u003E61.20\u003C\u002Fspan\u003E.into(),\n    ]\n    .into_boxed_slice()\n}\n\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F Typed arrays are only available for number types.\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F For example, the function below will return a JS Int32Array type.\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-meta\"\u003E#[wasm_bindgen]\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003Epub\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Etyped_array_example\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E(_array: \u003Cspan class=\"hljs-built_in\"\u003EBox\u003C\u002Fspan\u003E&lt;[\u003Cspan class=\"hljs-built_in\"\u003Ei32\u003C\u002Fspan\u003E]&gt;) -&gt; \u003Cspan class=\"hljs-built_in\"\u003EBox\u003C\u002Fspan\u003E&lt;[\u003Cspan class=\"hljs-built_in\"\u003Ei32\u003C\u002Fspan\u003E]&gt; {\n    \u003Cspan class=\"hljs-built_in\"\u003Evec!\u003C\u002Fspan\u003E[\u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E2\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E3\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E4\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E5\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E6\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E7\u003C\u002Fspan\u003E].into_boxed_slice()\n}\n\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F When it comes to Option:\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F - Some returns the value inside.\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F - None returns a JS undefined.\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-meta\"\u003E#[wasm_bindgen(catch)]\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003Epub\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Eoption_example\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E() -&gt; \u003Cspan class=\"hljs-built_in\"\u003EOption\u003C\u002Fspan\u003E&lt;\u003Cspan class=\"hljs-built_in\"\u003Ei32\u003C\u002Fspan\u003E&gt; {\n    \u003Cspan class=\"hljs-literal\"\u003ENone\u003C\u002Fspan\u003E\n}\n\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F When it comes to Result\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F - Result&lt;T, JsValue&gt; is the only supported signature. T must be convertible to a JsValue.\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F - #[wasm_bindgen(catch)] must be used when returning a result.\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F - Err will be equivalent to a JS thrown error.\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F - Ok will return the value inside.\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-meta\"\u003E#[wasm_bindgen]\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003Epub\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Eresult_example\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E() -&gt; \u003Cspan class=\"hljs-built_in\"\u003EResult\u003C\u002Fspan\u003E&lt;\u003Cspan class=\"hljs-built_in\"\u003Ei32\u003C\u002Fspan\u003E, JsValue&gt; {\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F With the wasm prelude imported, we can convert most common types by calling .into()\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-literal\"\u003EErr\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-string\"\u003E\"Look Pa, I'm throwing a JS error!\"\u003C\u002Fspan\u003E.into())\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EOnce the project is built again, these functions can be directly used in our web page. Feel free to play around and print the values returned.\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-html\"\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Escript\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-attr\"\u003Etype\u003C\u002Fspan\u003E=\u003Cspan class=\"hljs-string\"\u003E\"module\"\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\u003Cspan class=\"javascript\"\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Eimport\u003C\u002Fspan\u003E * \u003Cspan class=\"hljs-keyword\"\u003Eas\u003C\u002Fspan\u003E wasm \u003Cspan class=\"hljs-keyword\"\u003Efrom\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003E\".\u002Fpkg\u002Fhello_wasm.js\"\u003C\u002Fspan\u003E;\n\n  wasm.default().then(\u003Cspan class=\"hljs-function\"\u003E(\u003Cspan class=\"hljs-params\"\u003E\u003Cspan class=\"hljs-built_in\"\u003Emodule\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E) =&gt;\u003C\u002Fspan\u003E {\n    wasm.char_example(\u003Cspan class=\"hljs-string\"\u003E\"R\"\u003C\u002Fspan\u003E);\n    wasm.string_example(\u003Cspan class=\"hljs-string\"\u003E\"Jane\"\u003C\u002Fspan\u003E);\n    wasm.str_example(\u003Cspan class=\"hljs-string\"\u003E\"John\"\u003C\u002Fspan\u003E);\n    wasm.number_example(\u003Cspan class=\"hljs-number\"\u003E28\u003C\u002Fspan\u003E);\n    wasm.mixed_array_example([\u003Cspan class=\"hljs-number\"\u003E2\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-literal\"\u003Enull\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-literal\"\u003Eundefined\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-string\"\u003E\"Hola\"\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E]);\n    wasm.typed_array_example([\u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E2\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E3\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E4\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E5\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E6\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E7\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E8\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E9\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E10\u003C\u002Fspan\u003E]);\n    wasm.option_example();\n    wasm.result_example();\n  });\n\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Escript\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch2\u003EExporting Structs &amp; Enums\u003C\u002Fh2\u003E\n\u003Cp\u003EExpanding on what was explored above, enums and structs are a fairly simple export. Although there are some restrictions, the syntax should still feel like day-to-day Rust.\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-rust\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Euse\u003C\u002Fspan\u003E wasm_bindgen::prelude::*;\n\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F When it comes to Enums:\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F - They  are C styled.\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F - JS represents them through an object with a number for each variant.\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-meta\"\u003E#[wasm_bindgen]\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003Epub\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-class\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Eenum\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EExampleEnum\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E {\n    Yes,\n    No,\n}\n\n\u003Cspan class=\"hljs-meta\"\u003E#[wasm_bindgen]\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003Epub\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Everify_enum_choice\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E(choice: ExampleEnum) -&gt; \u003Cspan class=\"hljs-built_in\"\u003Ebool\u003C\u002Fspan\u003E {\n    \u003Cspan class=\"hljs-keyword\"\u003Ematch\u003C\u002Fspan\u003E choice {\n        ExampleEnum::Yes =&gt; \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E,\n        ExampleEnum::No =&gt; \u003Cspan class=\"hljs-literal\"\u003Efalse\u003C\u002Fspan\u003E,\n    }\n}\n\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F When it comes to Structs:\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F - Cannot contain lifetimes or type parameters.\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F - Each field value must impl the Copy trait.\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-meta\"\u003E#[wasm_bindgen]\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003Epub\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-class\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Estruct\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EExampleStruct\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E {\n    \u003Cspan class=\"hljs-keyword\"\u003Epub\u003C\u002Fspan\u003E value: \u003Cspan class=\"hljs-built_in\"\u003Ei32\u003C\u002Fspan\u003E,\n}\n\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F For struct impl, we have the option for struct methods and type-level functions.\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F JS handles structs by creating a JS object with a pointer (i.o.w. we can use references!).\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-meta\"\u003E#[wasm_bindgen]\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003Eimpl\u003C\u002Fspan\u003E ExampleStruct {\n    \u003Cspan class=\"hljs-keyword\"\u003Epub\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Enew\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E(value: \u003Cspan class=\"hljs-built_in\"\u003Ei32\u003C\u002Fspan\u003E) -&gt; ExampleStruct {\n        ExampleStruct { value }\n    }\n\n    \u003Cspan class=\"hljs-keyword\"\u003Epub\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Eread_method\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E(&amp;\u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E) -&gt; \u003Cspan class=\"hljs-built_in\"\u003Ei32\u003C\u002Fspan\u003E {\n        \u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E.value\n    }\n\n    \u003Cspan class=\"hljs-keyword\"\u003Epub\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Ewrite_method\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E(&amp;\u003Cspan class=\"hljs-keyword\"\u003Emut\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E, value: \u003Cspan class=\"hljs-built_in\"\u003Ei32\u003C\u002Fspan\u003E) {\n        \u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E.value = value;\n    }\n\n    \u003Cspan class=\"hljs-keyword\"\u003Epub\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Etransfer_ownership\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E) -&gt; ExampleStruct {\n        \u003Cspan class=\"hljs-keyword\"\u003Eself\u003C\u002Fspan\u003E\n    }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003ENow we can import the struct and enum directly into our JS code. Once a struct is instantiated, we can call its Wasm compatible methods.\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-html\"\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Escript\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-attr\"\u003Etype\u003C\u002Fspan\u003E=\u003Cspan class=\"hljs-string\"\u003E\"module\"\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\u003Cspan class=\"javascript\"\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Eimport\u003C\u002Fspan\u003E * \u003Cspan class=\"hljs-keyword\"\u003Eas\u003C\u002Fspan\u003E wasm \u003Cspan class=\"hljs-keyword\"\u003Efrom\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003E\".\u002Fpkg\u002Fhello_wasm.js\"\u003C\u002Fspan\u003E;\n\n  wasm.default().then(\u003Cspan class=\"hljs-function\"\u003E(\u003Cspan class=\"hljs-params\"\u003E\u003Cspan class=\"hljs-built_in\"\u003Emodule\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E) =&gt;\u003C\u002Fspan\u003E {\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F Enum \\\\\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E rustEnum = wasm.ExampleEnum.Yes;\n    \u003Cspan class=\"hljs-built_in\"\u003Econsole\u003C\u002Fspan\u003E.log(wasm.verify_enum_choice(rustEnum));\n\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F Struct \\\\\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E rustStruct = wasm.ExampleStruct.new(\u003Cspan class=\"hljs-number\"\u003E6\u003C\u002Fspan\u003E);\n    \u003Cspan class=\"hljs-built_in\"\u003Econsole\u003C\u002Fspan\u003E.log(rustStruct); \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F this will contain a pointer\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-built_in\"\u003Econsole\u003C\u002Fspan\u003E.log(rustStruct.value);\n\n    rustStruct.write_method(\u003Cspan class=\"hljs-number\"\u003E200\u003C\u002Fspan\u003E);\n    \u003Cspan class=\"hljs-built_in\"\u003Econsole\u003C\u002Fspan\u003E.log(rustStruct.read_method());\n\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E newRustStruct = rustStruct.transfer_ownership();\n    rustStruct.read_method(); \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F rustStruct is now invalid. An error will throw.\u003C\u002Fspan\u003E\n  });\n\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Escript\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EWe've provided an output image of the script below to better show how these types work. Notice how the enums and structs are represented in JS.\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"\u002Fposts\u002Fgetting-started-with-webassembly-and-rust\u002Fimages\u002Fenum_and_struct_example_log.png\" alt=\"Web console output of Rust struct and enum exports\"\u003E\u003C\u002Fp\u003E\n\u003Ch2\u003EManually Creating Bindings\u003C\u002Fh2\u003E\n\u003Cp\u003EThe \u003Ccode\u003Ewasm-bindgen\u003C\u002Fcode\u003E crate gives us powerful tooling for talking to JS. However, there are no direct bindings for the JS standard or Web APIs. That's where \u003Ccode\u003Eweb-sys\u003C\u002Fcode\u003E and \u003Ccode\u003Ejs-sys\u003C\u002Fcode\u003E come in. Both crates provide ready made bindings that give us a standard interface to work with.\u003C\u002Fp\u003E\n\u003Cp\u003EOf course, these crates don't cover everything and we need to create our own bindings for anything missing. A common example is wrapping over custom JS classes and functions. When you first opened \u003Ccode\u003Esrc\u002Flib.rs\u003C\u002Fcode\u003E you might've noticed a binding was created for the \u003Ccode\u003Ealert()\u003C\u002Fcode\u003E function.\u003C\u002Fp\u003E\n\u003Cp\u003ETo see how to create our own custom bindings, we'll first look over the JS code we want Rust to bind for.\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-html\"\u003E\u003Cspan class=\"hljs-comment\"\u003E&lt;!--\n  For simplicity, we'll add a class declaration to the global namespace.\n  The goal, from rust, is to create this class, call a method, and get\u002Fset a property.\n--&gt;\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Escript\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\u003Cspan class=\"javascript\"\u003E\n  \u003Cspan class=\"hljs-class\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Eclass\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003ECoordinate\u003C\u002Fspan\u003E \u003C\u002Fspan\u003E{\n    \u003Cspan class=\"hljs-keyword\"\u003Econstructor\u003C\u002Fspan\u003E(x, y) {\n      \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.x = x;\n      \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.y = y;\n    }\n\n    printValues() {\n      \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003E`(x:\u003Cspan class=\"hljs-subst\"\u003E${\u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.x}\u003C\u002Fspan\u003E y:\u003Cspan class=\"hljs-subst\"\u003E${\u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.y}\u003C\u002Fspan\u003E)`\u003C\u002Fspan\u003E;\n    }\n  }\n\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Escript\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\n\n\u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Escript\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-attr\"\u003Etype\u003C\u002Fspan\u003E=\u003Cspan class=\"hljs-string\"\u003E\"module\"\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\u003Cspan class=\"javascript\"\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Eimport\u003C\u002Fspan\u003E * \u003Cspan class=\"hljs-keyword\"\u003Eas\u003C\u002Fspan\u003E wasm \u003Cspan class=\"hljs-keyword\"\u003Efrom\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003E\".\u002Fpkg\u002Fhello_wasm.js\"\u003C\u002Fspan\u003E;\n\n  wasm.default().then(\u003Cspan class=\"hljs-function\"\u003E(\u003Cspan class=\"hljs-params\"\u003E\u003Cspan class=\"hljs-built_in\"\u003Emodule\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E) =&gt;\u003C\u002Fspan\u003E {\n    wasm.manual_bindings_example();\n  });\n\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Escript\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EOn top of binding the Coordinates class, below are some examples on how to do the same for various JS functions.\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-Rust\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Euse\u003C\u002Fspan\u003E wasm_bindgen::prelude::*;\n\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F Although we're using what's in the global namespace, we can also import from other modules.\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F #[wasm_bindgen(module = \".\u002Fbar\")]\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F extern \"C\" {}\u003C\u002Fspan\u003E\n\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F Binding JS involves a bit of boilerplate because we have to specify each name\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F and signature to bind.\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-meta\"\u003E#[wasm_bindgen]\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003Eextern\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003E\"C\"\u003C\u002Fspan\u003E {\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F Bindings must be named as their JS equivalent\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Ealert\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E(s: &amp;\u003Cspan class=\"hljs-built_in\"\u003Estr\u003C\u002Fspan\u003E);\n\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F A different name can be specified as long as the original name is passed to the macro.\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-meta\"\u003E#[wasm_bindgen(js_name = prompt)]\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Eask\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E(s: &amp;\u003Cspan class=\"hljs-built_in\"\u003Estr\u003C\u002Fspan\u003E) -&gt; \u003Cspan class=\"hljs-built_in\"\u003EString\u003C\u002Fspan\u003E;\n\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F Functions can be from any js namespace.\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-meta\"\u003E#[wasm_bindgen(js_namespace = console)]\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Elog\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E(s: &amp;\u003Cspan class=\"hljs-built_in\"\u003Estr\u003C\u002Fspan\u003E);\n\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F Using a different name allows us to specify various signatures.\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-meta\"\u003E#[wasm_bindgen(js_namespace = console, js_name = log)]\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Elog_num\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E(n: \u003Cspan class=\"hljs-built_in\"\u003Ei32\u003C\u002Fspan\u003E);\n\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F* JS Class example *\\\\\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F The process is a little verbose because create a binding for\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F each part of the class we want (class name, constructor, methods, setters, getters).\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-class\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Etype\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003ECoordinate\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E;\n\n    \u003Cspan class=\"hljs-meta\"\u003E#[wasm_bindgen(constructor)]\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Enew\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E(x: \u003Cspan class=\"hljs-built_in\"\u003Ei32\u003C\u002Fspan\u003E, y: \u003Cspan class=\"hljs-built_in\"\u003Ei32\u003C\u002Fspan\u003E) -&gt; Coordinate;\n\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F methods must match the naming in the class declaration.\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-meta\"\u003E#[wasm_bindgen(method)]\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EprintValues\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E(this: &amp;Coordinate) -&gt; \u003Cspan class=\"hljs-built_in\"\u003EString\u003C\u002Fspan\u003E;\n\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F getters are named as the property we want.\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-meta\"\u003E#[wasm_bindgen(getter, method)]\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Ex\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E(this: &amp;Coordinate) -&gt; \u003Cspan class=\"hljs-built_in\"\u003Ei32\u003C\u002Fspan\u003E;\n\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F setters are named the same as getters but with a `set_` prefix.\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-meta\"\u003E#[wasm_bindgen(setter, method)]\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Eset_x\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E(this: &amp;Coordinate, x: \u003Cspan class=\"hljs-built_in\"\u003Ei32\u003C\u002Fspan\u003E);\n}\n\n\u003Cspan class=\"hljs-meta\"\u003E#[wasm_bindgen]\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003Epub\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Emanual_bindings_example\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E() {\n    alert(\u003Cspan class=\"hljs-string\"\u003E\"Hey buddy!\"\u003C\u002Fspan\u003E);\n    log(&amp;ask(\u003Cspan class=\"hljs-string\"\u003E\"Tell me about your day!\"\u003C\u002Fspan\u003E));\n\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E coordinates = Coordinate::new(-\u003Cspan class=\"hljs-number\"\u003E4\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E15\u003C\u002Fspan\u003E);\n    log_num(coordinates.x()); \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F prints -4\u003C\u002Fspan\u003E\n\n    coordinates.set_x(coordinates.x() * \u003Cspan class=\"hljs-number\"\u003E2\u003C\u002Fspan\u003E);\n    log(&amp;coordinates.printValues()); \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F prints (-8, 15)\u003C\u002Fspan\u003E\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E\u003Cimg src=\"\u002Fposts\u002Fgetting-started-with-webassembly-and-rust\u002Fimages\u002Fmanual_bindings_example.gif\" alt=\"Browser and console output of the manually created Rust Wasm bindings\"\u003E\u003C\u002Fp\u003E\n\u003Ch2\u003EInteracting with Web APIs\u003C\u002Fh2\u003E\n\u003Cp\u003EThe majority essential web APIs are provided and documented by the \u003Ccode\u003Eweb-sys\u003C\u002Fcode\u003E crate. After specifying what APIs we want, we can:\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EEdit HTML elements.\u003C\u002Fli\u003E\n\u003Cli\u003EAdd event listeners.\u003C\u002Fli\u003E\n\u003Cli\u003EPrint to the web console.\u003C\u002Fli\u003E\n\u003Cli\u003EDraw on a canvas.\u003C\u002Fli\u003E\n\u003Cli\u003EAnd more!\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003ESince the list is extensive, we'll simply cover how to set up and use this create. Add the following to the project's \u003Ccode\u003ECargo.toml\u003C\u002Fcode\u003E and then specify each web API you want to use.\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-toml\"\u003E\u003Cspan class=\"hljs-section\"\u003E[dependencies]\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-attr\"\u003Eweb-sys\u003C\u002Fspan\u003E = { version = \u003Cspan class=\"hljs-string\"\u003E\"0.3.39\"\u003C\u002Fspan\u003E, features = [\u003Cspan class=\"hljs-string\"\u003E'console'\u003C\u002Fspan\u003E] }\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-rust\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Euse\u003C\u002Fspan\u003E wasm_bindgen::prelude::*;\n\u003Cspan class=\"hljs-keyword\"\u003Euse\u003C\u002Fspan\u003E web_sys::console;\n\n\u003Cspan class=\"hljs-meta\"\u003E#[wasm_bindgen]\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003Epub\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Eprint_things\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E() {\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F console has multiple log_x functions that represent how many items are being printed.\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F log_x takes in a reference to a JsValue so we need to convert the values we want to print.\u003C\u002Fspan\u003E\n  console::log_1(&amp;\u003Cspan class=\"hljs-string\"\u003E\"Printing from Rust!!\"\u003C\u002Fspan\u003E.into());\n  console::log_2(&amp;\u003Cspan class=\"hljs-string\"\u003E\"Numbers: \"\u003C\u002Fspan\u003E.into(), &amp;\u003Cspan class=\"hljs-number\"\u003E1234\u003C\u002Fspan\u003E.into());\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E\u003Ccode\u003Eweb-sys\u003C\u002Fcode\u003E Resources:\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fdocs.rs\u002Fcrate\u002Fweb-sys\u002F0.3.39\u002Fsource\u002FCargo.toml\"\u003EAvailable Crate features\u003C\u002Fa\u003E: The full list of Web APIs.\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Frustwasm.github.io\u002Fdocs\u002Fwasm-bindgen\u002Fexamples\u002Fdom.html\"\u003EOfficial Example\u003C\u002Fa\u003E: Covers basic DOM manipulation.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003ERemember to take a look at the \u003Ccode\u003Ejs-sys\u003C\u002Fcode\u003E crate if you find yourself needing to import types and functions from standard JS.\u003C\u002Fp\u003E\n\u003Ch1\u003EClosing thoughts\u003C\u002Fh1\u003E\n\u003Cp\u003EAlthough we couldn't cover everything (Wasm has more to offer than can fit in just one blog post), I hope this guide was able to jump start your journey into WebAssembly! I highly encourage going though the \u003Ca href=\"https:\u002F\u002Frustwasm.github.io\u002Fdocs\u002Fwasm-bindgen\u002F\"\u003Ewasm-bindgen docs\u003C\u002Fa\u003E to go over what we couldn't cover here. It covers more in-depth examples and important topics like \u003Ca href=\"https:\u002F\u002Frustwasm.github.io\u002Fdocs\u002Fwasm-bindgen\u002Freference\u002Farbitrary-data-with-serde.html\"\u003ESending Arbitrary Data Between JS &amp; Rust\u003C\u002Fa\u003E. Keep in mind that the Rust WebAssembly ecosystem is still growing and it's only going to get better from here!\u003C\u002Fp\u003E\n",date:"2020-7-26",excerpt:"",printDate:"July 26, 2020",printReadingTime:"13 min read"}}]};if('serviceWorker' in navigator)navigator.serviceWorker.register('/service-worker.js');(function(){try{eval("async function x(){}");var main="/client/client.c2d13623.js"}catch(e){main="/client/legacy/client.508b8b7c.js"};var s=document.createElement("script");try{new Function("if(0)import('')")();s.src=main;s.type="module";s.crossOrigin="use-credentials";}catch(e){s.src="/client/shimport@1.0.1.js";s.setAttribute("data-main",main);}document.head.appendChild(s);}());</script> 