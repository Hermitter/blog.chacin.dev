{"title":"Getting Started with WebAssembly and Rust","poster":"posts/getting-started-with-webassembly-and-rust/poster.png","frontCover":"../posts/getting-started-with-webassembly-and-rust/frontCover.jpg","keywords":"rust, web, webassembly","description":"Learn how to run Rust programs on the web","slug":"getting-started-with-webassembly-and-rust","html":"<h1>Getting Started with WebAssembly &amp; Rust</h1>\n<blockquote>\n<p>Originally written for <a href=\"https://blog.logrocket.com/getting-started-with-webassembly-and-rust/\">LogRocket</a> and posted here with their permission.</p>\n</blockquote>\n<p>This guide is an introduction on how to set up and work with a Rust WebAssembly environment. As for what you need to know, a basic understanding of Rust and web development should suffice.</p>\n<p>I initially picked up Rust because of the fantastic work the team has done in supporting and pushing WebAssembly. Their <a href=\"https://rustwasm.github.io/docs/book/\">official documentation</a> is a great introduction for building an example project!</p>\n<h1>Understanding WebAssembly</h1>\n<p>WebAssembly (also known as Wasm) is a binary instruction format that most browsers have started to support. This enables languages, such as Rust, C, C++ Go, etc., to be compiled and ran in a web browser.</p>\n<p>To clear up some misunderstandings, WebAssembly is <strong>not</strong> a replacement for JavaScript (also known as JS). Rather, it should be thought of as a way of offloading computationally heavy tasks to a more suitable language. Another benefit of this is that existing projects and libraries can now be ported to the web without needing to suffer through rewriting them in JS and the performance hits that come with that.</p>\n<p>For those interested in taking the Wasm specification outside the web, The <a href=\"https://wasi.dev/\">WebAssembly System Interface</a> (WASI) may be of interest to you!</p>\n<h1>Downloading the Tools</h1>\n<p>With everything out of the way, we can start setting up our environment! Be sure to have the following installed on your computer.</p>\n<ul>\n<li><a href=\"https://www.rust-lang.org/tools/install\">Rust</a> (Ideally, an up to date version)</li>\n<li>Modern Web Browser (Internet Explorer doesn't count!)</li>\n<li>Your favorite text editor</li>\n<li>A way to host a simple webserver (to avoid the browser nagging about cross-origin requests being blocked)\n<ul>\n<li>If you have Python installed, there's a nifty command for this!</li>\n</ul></li>\n<li><a href=\"https://rustwasm.github.io/wasm-pack/installer/\">wasm-pack CLI</a></li>\n</ul>\n<p>Why do we need wasm-pack? To reference from Ashley Williams' <a href=\"https://hacks.mozilla.org/2018/04/hello-wasm-pack/\">Hello wasm-pack</a> blog post,</p>\n<blockquote>\n<p>wasm-pack is a tool for assembling and packaging Rust crates that target WebAssembly. These packages can be published to the npm Registry and used alongside other packages. This means you can use them side-by-side with JS and other packages, and in many kinds of applications.</p>\n</blockquote>\n<p>For those that don't know, Rust crates are close to what packages and libraries are for other languages. Crates work directly with Rust's build system and package manager Cargo.</p>\n<h1>Creating &amp; Building a Wasm Package</h1>\n<p>To create a new Wasm project, we can utilize the <code>wasm-pack</code> CLI. This should be familiar for those that create Rust projects through the <code>cargo</code> CLI.</p>\n<pre><code class=\"language-sh\">wasm-pack new hello-wasm\n<span class=\"hljs-built_in\">cd</span> hello-wasm\n</code></pre>\n<p>The generated project is essentially a Rust library with boilerplate Wasm code.</p>\n<p><img src=\"/posts/getting-started-with-webassembly-and-rust/images/project_file_structure.png\" alt=\"project directory from the wasm-pack build command\"></p>\n<p>Looking at the commands available in wasm-pack, it's clear that there's a focus for creating and publishing npm packages.</p>\n<pre><code>WASM-PACK SUBCOMMANDS:\n    build      üèóÔ∏è  build your npm package!\n    <span class=\"hljs-keyword\">help</span>       Prints this message <span class=\"hljs-keyword\">or</span> the <span class=\"hljs-keyword\">help</span> <span class=\"hljs-keyword\">of</span> the given subcommand(s)\n    login      üë§  <span class=\"hljs-keyword\">Add</span> an npm registry <span class=\"hljs-keyword\">user</span> <span class=\"hljs-keyword\">account</span>! (aliases: adduser, <span class=\"hljs-keyword\">add</span>-<span class=\"hljs-keyword\">user</span>)\n    <span class=\"hljs-keyword\">new</span>        üêë <span class=\"hljs-keyword\">create</span> a <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">project</span> <span class=\"hljs-keyword\">with</span> a <span class=\"hljs-keyword\">template</span>\n    pack       üç±  <span class=\"hljs-keyword\">create</span> a tar <span class=\"hljs-keyword\">of</span> your npm <span class=\"hljs-keyword\">package</span> but don<span class=\"hljs-string\">'t publish!\n    publish    üéÜ  pack up your npm package and publish!\n    test       üë©‚Äçüî¨  test your wasm!\n</span></code></pre>\n<p>Although this is great for projects that have bundlers (Webpack, Rollup, etc.), we're aiming for simple setup where we can import our Wasm binary in an HTML file. Thankfully, wasm-pack <code>build</code> has an argument to target other environments!</p>\n<pre><code>-t, --<span class=\"hljs-keyword\">target</span> &lt;<span class=\"hljs-keyword\">target</span>&gt;        Sets the <span class=\"hljs-keyword\">target</span> environment. [possible values: bundler, nodejs, web, no-modules]\n                                [<span class=\"hljs-keyword\">default</span>: bundler]\n</code></pre>\n<p>The <code>web</code> target is exactly what we want! Once built, the output will create a <code>pkg</code> folder with multiple files that serve as the glue code between Wasm and JS. By the end of it, our Wasm binary will be exposed through a <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules\">JavaScript Module</a>.</p>\n<pre><code class=\"language-sh\">wasm-pack build --target web\n</code></pre>\n<h1>Running Wasm in the Browser</h1>\n<p>With the Rust code compiled to Wasm, we can begin going over how call it from JS. Start by creating a file called <code>index.html</code> in root of the project, and add the following:</p>\n<pre><code class=\"language-html\"><span class=\"hljs-meta\">&lt;!DOCTYPE html&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">\"utf-8\"</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>My Wasm Project<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"module\"</span>&gt;</span><span class=\"javascript\">\n      <span class=\"hljs-comment\">// Importing WASM for the web target requires us to call an init function provided by the default module export.</span>\n      <span class=\"hljs-comment\">// This is planned to be changed in the future.</span>\n      <span class=\"hljs-keyword\">import</span> { <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">as</span> wasm, greet } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"./pkg/hello_wasm.js\"</span>;\n\n      wasm().then(<span class=\"hljs-function\">(<span class=\"hljs-params\"><span class=\"hljs-built_in\">module</span></span>) =&gt;</span> {\n        <span class=\"hljs-comment\">// The boiler plate project comes with a `greet` function that calls:</span>\n        <span class=\"hljs-comment\">// `alert(\"Hello, hello-wasm!\");`</span>\n        greet();\n      });\n    </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span>\n</code></pre>\n<p>For security reasons, browsers tend to not let you import local resources from <code>file://</code>. This prevents us from importing the Wasm binary, but an easy solution is to just start a quick webserver.</p>\n<p>If you have Python installed, you can use one of the following commands for this:</p>\n<ul>\n<li>Python 3: <code>python -m http.server 8000</code></li>\n<li>Python 2: <code>python -m SimpleHTTPServer 8000</code></li>\n</ul>\n<p>We now have Rust code ready to run in a browser! Visit http://localhost:8000 to see it live. It should be a blank page with an alert.</p>\n<p><img src=\"/posts/getting-started-with-webassembly-and-rust/images/wasm_hello_world.png\" alt=\"Wasm project loaded on a webpage\"></p>\n<h1>Rust and JavaScript Interop</h1>\n<blockquote>\n<p>For the following code examples, you can edit the <code>index.html</code> &amp; <code>src/lib.rs</code> files to play around with the new changes. <strong>Remember to build each time you edit your Rust code!</strong></p>\n</blockquote>\n<p>Now that you're familiar with building a project, it's time to go over how to work with it. By default, Rust doesn't directly have the ability to communicate with JS or Web APIs. This functionality is enabled through <a href=\"https://rustwasm.github.io/docs/wasm-bindgen/\">wasm-bindgen</a>. The project itself consists of multiple crates and a CLI tool. We've actually been using its CLI through <code>wasm-pack</code>!</p>\n<p>Crates from wasm-bindgen:</p>\n<ul>\n<li><a href=\"https://docs.rs/wasm-bindgen/\">wasm-bindgen</a>: Generates bindings and glue code between Wasm and JS.</li>\n<li><a href=\"https://docs.rs/web-sys/\">web-sys</a>: Bindings for Web APIs.</li>\n<li><a href=\"https://docs.rs/js-sys/\">js-sys</a>: Bindings for JavaScript's standard, built-in objects, including their methods and properties.</li>\n<li><a href=\"https://docs.rs/wasm-bindgen-futures\">wasm_bindgen_futures</a>: Facilitates converting between\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\">JavaScript Promises</a> to <a href=\"https://docs.rs/futures/0.3.5/futures/\">Rust Futures</a>.</li>\n</ul>\n<h2>Exporting Common Types</h2>\n<p>By importing <code>wasm_bindgen::prelude::*</code>, we're given powerful abstractions for talking to JS. Here are some I want to highlight:</p>\n<ul>\n<li><code>#[wasm_bindgen]</code>: Macro that automatically handles most of our bindings between Rust and JS.</li>\n<li><code>JsValue</code>: A representation for a data owned by JS.</li>\n<li><code>UnwrapThrowExt</code>: A trait extension for\n<code>Option&lt;T&gt;</code> and <code>Result&lt;T, E&gt;</code>.</li>\n</ul>\n<p>Assuming you're editing <code>src/lib.rs</code>, the examples below show how to receive/return values with Wasm. Note that variables with an underscore (like <code>_c</code>) is a Rust convention for expressing that it's unused.</p>\n<pre><code class=\"language-Rust\"><span class=\"hljs-keyword\">use</span> wasm_bindgen::prelude::*;\n\n<span class=\"hljs-comment\">// JS doesn't have a chars type which means:</span>\n<span class=\"hljs-comment\">// - The _c argument is the first char of a JS string.</span>\n<span class=\"hljs-comment\">// - The char returned will be a JS string.</span>\n<span class=\"hljs-meta\">#[wasm_bindgen]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">char_example</span></span>(_c: <span class=\"hljs-built_in\">char</span>) -&gt; <span class=\"hljs-built_in\">char</span> {\n    'üöÄ'\n}\n\n<span class=\"hljs-meta\">#[wasm_bindgen]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">string_example</span></span>(s: <span class=\"hljs-built_in\">String</span>) -&gt; <span class=\"hljs-built_in\">String</span> {\n    <span class=\"hljs-built_in\">format!</span>(<span class=\"hljs-string\">\"Hello {}\"</span>, s)\n}\n\n<span class=\"hljs-comment\">// str cannot be used as a return type.</span>\n<span class=\"hljs-comment\">// This is because we can't return borrowed references with the wasm_bindgen macro.</span>\n<span class=\"hljs-meta\">#[wasm_bindgen]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">str_example</span></span>(s: &amp;<span class=\"hljs-built_in\">str</span>) -&gt; <span class=\"hljs-built_in\">String</span> {\n    <span class=\"hljs-built_in\">format!</span>(<span class=\"hljs-string\">\"Hello {}\"</span>, s)\n}\n\n<span class=\"hljs-meta\">#[wasm_bindgen]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">number_example</span></span>(n: <span class=\"hljs-built_in\">i32</span>) -&gt; <span class=\"hljs-built_in\">i32</span> { <span class=\"hljs-comment\">// assume the same for u32, usize, etc.</span>\n    n+<span class=\"hljs-number\">100</span>\n}\n\n<span class=\"hljs-meta\">#[wasm_bindgen]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">bool_example</span></span>(_b: <span class=\"hljs-built_in\">bool</span>) -&gt; <span class=\"hljs-built_in\">bool</span> {\n    <span class=\"hljs-literal\">true</span>\n}\n\n<span class=\"hljs-comment\">// `Box&lt;[JsValue]&gt;` are the representation for a JS array object.</span>\n<span class=\"hljs-comment\">// When it comes to Js Arrays:</span>\n<span class=\"hljs-comment\">// - They are iterable.</span>\n<span class=\"hljs-comment\">// - Can contain multiple types by being of type JsValue (strictly typed arrays exist for numbers).</span>\n<span class=\"hljs-comment\">// - Don't really support N-dimensional arrays and are expensive to work with.</span>\n<span class=\"hljs-meta\">#[wasm_bindgen]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">mixed_array_example</span></span>(array: <span class=\"hljs-built_in\">Box</span>&lt;[JsValue]&gt;) -&gt; <span class=\"hljs-built_in\">Box</span>&lt;[JsValue]&gt; {\n    <span class=\"hljs-keyword\">for</span> value <span class=\"hljs-keyword\">in</span> array.iter() {\n        <span class=\"hljs-comment\">// compute things...</span>\n    }\n\n    <span class=\"hljs-built_in\">vec!</span>[\n        <span class=\"hljs-string\">\"Hello\"</span>.into(),\n        <span class=\"hljs-number\">512</span>.into(),\n        JsValue::NULL,\n        JsValue::UNDEFINED,\n        <span class=\"hljs-number\">61.20</span>.into(),\n    ]\n    .into_boxed_slice()\n}\n\n<span class=\"hljs-comment\">// Typed arrays are only available for number types.</span>\n<span class=\"hljs-comment\">// For example, the function below will return a JS Int32Array type.</span>\n<span class=\"hljs-meta\">#[wasm_bindgen]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">typed_array_example</span></span>(_array: <span class=\"hljs-built_in\">Box</span>&lt;[<span class=\"hljs-built_in\">i32</span>]&gt;) -&gt; <span class=\"hljs-built_in\">Box</span>&lt;[<span class=\"hljs-built_in\">i32</span>]&gt; {\n    <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">7</span>].into_boxed_slice()\n}\n\n<span class=\"hljs-comment\">// When it comes to Option:</span>\n<span class=\"hljs-comment\">// - Some returns the value inside.</span>\n<span class=\"hljs-comment\">// - None returns a JS undefined.</span>\n<span class=\"hljs-meta\">#[wasm_bindgen(catch)]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">option_example</span></span>() -&gt; <span class=\"hljs-built_in\">Option</span>&lt;<span class=\"hljs-built_in\">i32</span>&gt; {\n    <span class=\"hljs-literal\">None</span>\n}\n\n<span class=\"hljs-comment\">// When it comes to Result</span>\n<span class=\"hljs-comment\">// - Result&lt;T, JsValue&gt; is the only supported signature. T must be convertible to a JsValue.</span>\n<span class=\"hljs-comment\">// - #[wasm_bindgen(catch)] must be used when returning a result.</span>\n<span class=\"hljs-comment\">// - Err will be equivalent to a JS thrown error.</span>\n<span class=\"hljs-comment\">// - Ok will return the value inside.</span>\n<span class=\"hljs-meta\">#[wasm_bindgen]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">result_example</span></span>() -&gt; <span class=\"hljs-built_in\">Result</span>&lt;<span class=\"hljs-built_in\">i32</span>, JsValue&gt; {\n    <span class=\"hljs-comment\">// With the wasm prelude imported, we can convert most common types by calling .into()</span>\n    <span class=\"hljs-literal\">Err</span>(<span class=\"hljs-string\">\"Look Pa, I'm throwing a JS error!\"</span>.into())\n}\n</code></pre>\n<p>Once the project is built again, these functions can be directly used in our web page. Feel free to play around and print the values returned.</p>\n<pre><code class=\"language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"module\"</span>&gt;</span><span class=\"javascript\">\n  <span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> wasm <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"./pkg/hello_wasm.js\"</span>;\n\n  wasm.default().then(<span class=\"hljs-function\">(<span class=\"hljs-params\"><span class=\"hljs-built_in\">module</span></span>) =&gt;</span> {\n    wasm.char_example(<span class=\"hljs-string\">\"R\"</span>);\n    wasm.string_example(<span class=\"hljs-string\">\"Jane\"</span>);\n    wasm.str_example(<span class=\"hljs-string\">\"John\"</span>);\n    wasm.number_example(<span class=\"hljs-number\">28</span>);\n    wasm.mixed_array_example([<span class=\"hljs-number\">2</span>, <span class=\"hljs-literal\">null</span>, <span class=\"hljs-literal\">undefined</span>, <span class=\"hljs-string\">\"Hola\"</span>, <span class=\"hljs-literal\">true</span>]);\n    wasm.typed_array_example([<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">10</span>]);\n    wasm.option_example();\n    wasm.result_example();\n  });\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n</code></pre>\n<h2>Exporting Structs &amp; Enums</h2>\n<p>Expanding on what was explored above, enums and structs are a fairly simple export. Although there are some restrictions, the syntax should still feel like day-to-day Rust.</p>\n<pre><code class=\"language-rust\"><span class=\"hljs-keyword\">use</span> wasm_bindgen::prelude::*;\n\n<span class=\"hljs-comment\">// When it comes to Enums:</span>\n<span class=\"hljs-comment\">// - They  are C styled.</span>\n<span class=\"hljs-comment\">// - JS represents them through an object with a number for each variant.</span>\n<span class=\"hljs-meta\">#[wasm_bindgen]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">ExampleEnum</span></span> {\n    Yes,\n    No,\n}\n\n<span class=\"hljs-meta\">#[wasm_bindgen]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">verify_enum_choice</span></span>(choice: ExampleEnum) -&gt; <span class=\"hljs-built_in\">bool</span> {\n    <span class=\"hljs-keyword\">match</span> choice {\n        ExampleEnum::Yes =&gt; <span class=\"hljs-literal\">true</span>,\n        ExampleEnum::No =&gt; <span class=\"hljs-literal\">false</span>,\n    }\n}\n\n<span class=\"hljs-comment\">// When it comes to Structs:</span>\n<span class=\"hljs-comment\">// - Cannot contain lifetimes or type parameters.</span>\n<span class=\"hljs-comment\">// - Each field value must impl the Copy trait.</span>\n<span class=\"hljs-meta\">#[wasm_bindgen]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">ExampleStruct</span></span> {\n    <span class=\"hljs-keyword\">pub</span> value: <span class=\"hljs-built_in\">i32</span>,\n}\n\n<span class=\"hljs-comment\">// For struct impl, we have the option for struct methods and type-level functions.</span>\n<span class=\"hljs-comment\">// JS handles structs by creating a JS object with a pointer (i.o.w. we can use references!).</span>\n<span class=\"hljs-meta\">#[wasm_bindgen]</span>\n<span class=\"hljs-keyword\">impl</span> ExampleStruct {\n    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">new</span></span>(value: <span class=\"hljs-built_in\">i32</span>) -&gt; ExampleStruct {\n        ExampleStruct { value }\n    }\n\n    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">read_method</span></span>(&amp;<span class=\"hljs-keyword\">self</span>) -&gt; <span class=\"hljs-built_in\">i32</span> {\n        <span class=\"hljs-keyword\">self</span>.value\n    }\n\n    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">write_method</span></span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>, value: <span class=\"hljs-built_in\">i32</span>) {\n        <span class=\"hljs-keyword\">self</span>.value = value;\n    }\n\n    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">transfer_ownership</span></span>(<span class=\"hljs-keyword\">self</span>) -&gt; ExampleStruct {\n        <span class=\"hljs-keyword\">self</span>\n    }\n}\n</code></pre>\n<p>Now we can import the struct and enum directly into our JS code. Once a struct is instantiated, we can call its Wasm compatible methods.</p>\n<pre><code class=\"language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"module\"</span>&gt;</span><span class=\"javascript\">\n  <span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> wasm <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"./pkg/hello_wasm.js\"</span>;\n\n  wasm.default().then(<span class=\"hljs-function\">(<span class=\"hljs-params\"><span class=\"hljs-built_in\">module</span></span>) =&gt;</span> {\n    <span class=\"hljs-comment\">// Enum \\\\</span>\n    <span class=\"hljs-keyword\">let</span> rustEnum = wasm.ExampleEnum.Yes;\n    <span class=\"hljs-built_in\">console</span>.log(wasm.verify_enum_choice(rustEnum));\n\n    <span class=\"hljs-comment\">// Struct \\\\</span>\n    <span class=\"hljs-keyword\">let</span> rustStruct = wasm.ExampleStruct.new(<span class=\"hljs-number\">6</span>);\n    <span class=\"hljs-built_in\">console</span>.log(rustStruct); <span class=\"hljs-comment\">// this will contain a pointer</span>\n    <span class=\"hljs-built_in\">console</span>.log(rustStruct.value);\n\n    rustStruct.write_method(<span class=\"hljs-number\">200</span>);\n    <span class=\"hljs-built_in\">console</span>.log(rustStruct.read_method());\n\n    <span class=\"hljs-keyword\">let</span> newRustStruct = rustStruct.transfer_ownership();\n    rustStruct.read_method(); <span class=\"hljs-comment\">// rustStruct is now invalid. An error will throw.</span>\n  });\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n</code></pre>\n<p>We've provided an output image of the script below to better show how these types work. Notice how the enums and structs are represented in JS.</p>\n<p><img src=\"/posts/getting-started-with-webassembly-and-rust/images/enum_and_struct_example_log.png\" alt=\"Web console output of Rust struct and enum exports\"></p>\n<h2>Manually Creating Bindings</h2>\n<p>The <code>wasm-bindgen</code> crate gives us powerful tooling for talking to JS. However, there are no direct bindings for the JS standard or Web APIs. That's where <code>web-sys</code> and <code>js-sys</code> come in. Both crates provide ready made bindings that give us a standard interface to work with.</p>\n<p>Of course, these crates don't cover everything and we need to create our own bindings for anything missing. A common example is wrapping over custom JS classes and functions. When you first opened <code>src/lib.rs</code> you might've noticed a binding was created for the <code>alert()</code> function.</p>\n<p>To see how to create our own custom bindings, we'll first look over the JS code we want Rust to bind for.</p>\n<pre><code class=\"language-html\"><span class=\"hljs-comment\">&lt;!--\n  For simplicity, we'll add a class declaration to the global namespace.\n  The goal, from rust, is to create this class, call a method, and get/set a property.\n--&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n  <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Coordinate</span> </span>{\n    <span class=\"hljs-keyword\">constructor</span>(x, y) {\n      <span class=\"hljs-keyword\">this</span>.x = x;\n      <span class=\"hljs-keyword\">this</span>.y = y;\n    }\n\n    printValues() {\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">`(x:<span class=\"hljs-subst\">${<span class=\"hljs-keyword\">this</span>.x}</span> y:<span class=\"hljs-subst\">${<span class=\"hljs-keyword\">this</span>.y}</span>)`</span>;\n    }\n  }\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"module\"</span>&gt;</span><span class=\"javascript\">\n  <span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> wasm <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"./pkg/hello_wasm.js\"</span>;\n\n  wasm.default().then(<span class=\"hljs-function\">(<span class=\"hljs-params\"><span class=\"hljs-built_in\">module</span></span>) =&gt;</span> {\n    wasm.manual_bindings_example();\n  });\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n</code></pre>\n<p>On top of binding the Coordinates class, below are some examples on how to do the same for various JS functions.</p>\n<pre><code class=\"language-Rust\"><span class=\"hljs-keyword\">use</span> wasm_bindgen::prelude::*;\n\n<span class=\"hljs-comment\">// Although we're using what's in the global namespace, we can also import from other modules.</span>\n<span class=\"hljs-comment\">// #[wasm_bindgen(module = \"./bar\")]</span>\n<span class=\"hljs-comment\">// extern \"C\" {}</span>\n\n<span class=\"hljs-comment\">// Binding JS involves a bit of boilerplate because we have to specify each name</span>\n<span class=\"hljs-comment\">// and signature to bind.</span>\n<span class=\"hljs-meta\">#[wasm_bindgen]</span>\n<span class=\"hljs-keyword\">extern</span> <span class=\"hljs-string\">\"C\"</span> {\n    <span class=\"hljs-comment\">// Bindings must be named as their JS equivalent</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">alert</span></span>(s: &amp;<span class=\"hljs-built_in\">str</span>);\n\n    <span class=\"hljs-comment\">// A different name can be specified as long as the original name is passed to the macro.</span>\n    <span class=\"hljs-meta\">#[wasm_bindgen(js_name = prompt)]</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">ask</span></span>(s: &amp;<span class=\"hljs-built_in\">str</span>) -&gt; <span class=\"hljs-built_in\">String</span>;\n\n    <span class=\"hljs-comment\">// Functions can be from any js namespace.</span>\n    <span class=\"hljs-meta\">#[wasm_bindgen(js_namespace = console)]</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">log</span></span>(s: &amp;<span class=\"hljs-built_in\">str</span>);\n\n    <span class=\"hljs-comment\">// Using a different name allows us to specify various signatures.</span>\n    <span class=\"hljs-meta\">#[wasm_bindgen(js_namespace = console, js_name = log)]</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">log_num</span></span>(n: <span class=\"hljs-built_in\">i32</span>);\n\n    <span class=\"hljs-comment\">//* JS Class example *\\\\</span>\n    <span class=\"hljs-comment\">// The process is a little verbose because create a binding for</span>\n    <span class=\"hljs-comment\">// each part of the class we want (class name, constructor, methods, setters, getters).</span>\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title\">Coordinate</span></span>;\n\n    <span class=\"hljs-meta\">#[wasm_bindgen(constructor)]</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">new</span></span>(x: <span class=\"hljs-built_in\">i32</span>, y: <span class=\"hljs-built_in\">i32</span>) -&gt; Coordinate;\n\n    <span class=\"hljs-comment\">// methods must match the naming in the class declaration.</span>\n    <span class=\"hljs-meta\">#[wasm_bindgen(method)]</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">printValues</span></span>(this: &amp;Coordinate) -&gt; <span class=\"hljs-built_in\">String</span>;\n\n    <span class=\"hljs-comment\">// getters are named as the property we want.</span>\n    <span class=\"hljs-meta\">#[wasm_bindgen(getter, method)]</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">x</span></span>(this: &amp;Coordinate) -&gt; <span class=\"hljs-built_in\">i32</span>;\n\n    <span class=\"hljs-comment\">// setters are named the same as getters but with a `set_` prefix.</span>\n    <span class=\"hljs-meta\">#[wasm_bindgen(setter, method)]</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">set_x</span></span>(this: &amp;Coordinate, x: <span class=\"hljs-built_in\">i32</span>);\n}\n\n<span class=\"hljs-meta\">#[wasm_bindgen]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">manual_bindings_example</span></span>() {\n    alert(<span class=\"hljs-string\">\"Hey buddy!\"</span>);\n    log(&amp;ask(<span class=\"hljs-string\">\"Tell me about your day!\"</span>));\n\n    <span class=\"hljs-keyword\">let</span> coordinates = Coordinate::new(-<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">15</span>);\n    log_num(coordinates.x()); <span class=\"hljs-comment\">// prints -4</span>\n\n    coordinates.set_x(coordinates.x() * <span class=\"hljs-number\">2</span>);\n    log(&amp;coordinates.printValues()); <span class=\"hljs-comment\">// prints (-8, 15)</span>\n}\n</code></pre>\n<p><img src=\"/posts/getting-started-with-webassembly-and-rust/images/manual_bindings_example.gif\" alt=\"Browser and console output of the manually created Rust Wasm bindings\"></p>\n<h2>Interacting with Web APIs</h2>\n<p>The majority essential web APIs are provided and documented by the <code>web-sys</code> crate. After specifying what APIs we want, we can:</p>\n<ul>\n<li>Edit HTML elements.</li>\n<li>Add event listeners.</li>\n<li>Print to the web console.</li>\n<li>Draw on a canvas.</li>\n<li>And more!</li>\n</ul>\n<p>Since the list is extensive, we'll simply cover how to set up and use this create. Add the following to the project's <code>Cargo.toml</code> and then specify each web API you want to use.</p>\n<pre><code class=\"language-toml\"><span class=\"hljs-section\">[dependencies]</span>\n<span class=\"hljs-attr\">web-sys</span> = { version = <span class=\"hljs-string\">\"0.3.39\"</span>, features = [<span class=\"hljs-string\">'console'</span>] }\n</code></pre>\n<pre><code class=\"language-rust\"><span class=\"hljs-keyword\">use</span> wasm_bindgen::prelude::*;\n<span class=\"hljs-keyword\">use</span> web_sys::console;\n\n<span class=\"hljs-meta\">#[wasm_bindgen]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title\">print_things</span></span>() {\n  <span class=\"hljs-comment\">// console has multiple log_x functions that represent how many items are being printed.</span>\n  <span class=\"hljs-comment\">// log_x takes in a reference to a JsValue so we need to convert the values we want to print.</span>\n  console::log_1(&amp;<span class=\"hljs-string\">\"Printing from Rust!!\"</span>.into());\n  console::log_2(&amp;<span class=\"hljs-string\">\"Numbers: \"</span>.into(), &amp;<span class=\"hljs-number\">1234</span>.into());\n}\n</code></pre>\n<p><code>web-sys</code> Resources:</p>\n<ul>\n<li><a href=\"https://docs.rs/crate/web-sys/0.3.39/source/Cargo.toml\">Available Crate features</a>: The full list of Web APIs.</li>\n<li><a href=\"https://rustwasm.github.io/docs/wasm-bindgen/examples/dom.html\">Official Example</a>: Covers basic DOM manipulation.</li>\n</ul>\n<p>Remember to take a look at the <code>js-sys</code> crate if you find yourself needing to import types and functions from standard JS.</p>\n<h1>Closing thoughts</h1>\n<p>Although we couldn't cover everything (Wasm has more to offer than can fit in just one blog post), I hope this guide was able to jump start your journey into WebAssembly! I highly encourage going though the <a href=\"https://rustwasm.github.io/docs/wasm-bindgen/\">wasm-bindgen docs</a> to go over what we couldn't cover here. It covers more in-depth examples and important topics like <a href=\"https://rustwasm.github.io/docs/wasm-bindgen/reference/arbitrary-data-with-serde.html\">Sending Arbitrary Data Between JS &amp; Rust</a>. Keep in mind that the Rust WebAssembly ecosystem is still growing and it's only going to get better from here!</p>\n","date":"2020-7-26","excerpt":"","printDate":"July 26, 2020","printReadingTime":"13 min read"}